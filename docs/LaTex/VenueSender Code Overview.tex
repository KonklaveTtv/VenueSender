\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{fontspec}
\usepackage{xcolor}
\usepackage{geometry}
\usepackage{listings}
\usepackage{mdframed}

\setmainfont{Arial}

\definecolor{background}{RGB}{40,40,40}
\definecolor{textcolor}{RGB}{230,230,230}
\definecolor{accent}{RGB}{90,90,255}
\pagecolor{background}
\color{textcolor}

\geometry{a4paper, margin=0.8in, top=1.2in, bottom=1.2in}

\lstdefinestyle{mystyle}{
	backgroundcolor=\color{background},
	commentstyle=\color{accent},
	keywordstyle=\color{textcolor},
	numberstyle=\tiny\color{textcolor},
	stringstyle=\color{accent},
	basicstyle=\ttfamily\footnotesize\color{textcolor},
	breakatwhitespace=false,
	breaklines=true,
	captionpos=b,
	keepspaces=true,
	numbers=left,
	numbersep=5pt,
	showspaces=false,
	showstringspaces=false,
	showtabs=false,
	tabsize=2
}
\lstset{style=mystyle}

% Hyperref for links
\usepackage[colorlinks=true, allcolors=accent]{hyperref}

% Header/Footer setup for dark theme
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\lhead{\color{textcolor}VenueSender Codebase Overview}
\rhead{\color{textcolor}\thepage}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}
\renewcommand{\headrule}{\hbox to\headwidth{\color{accent}\leaders\hrule height \headrulewidth\hfill}}
\renewcommand{\footrule}{\hbox to\headwidth{\color{accent}\leaders\hrule height \footrulewidth\hfill}}

% Other packages
\usepackage{enumitem}
\usepackage{microtype}

\title{VenueSender Codebase Overview}


\author{Created by Spencer Lievens}
\date{\today}

\begin{document}
	
	\maketitle
	\tableofcontents
	\newpage
	
	\section{main.cpp}
	
	\subsection*{Source Code}
	\begin{mdframed}[backgroundcolor=background, hidealllines=false, innerleftmargin=15pt, innerrightmargin=5pt, innertopmargin=0pt, innerbottommargin=-5pt, linecolor=accent]
	\begin{lstlisting}[language=C++]
		#include "include/main.h"
		
		using namespace confPaths;
		using namespace std;
		
		ConfigManager configManager;
		CsvReader csvReader;
		CurlHandleWrapper curlWrapper;
		EmailManager emailManager;
		EncryptionManager encryptionManager;
		MenuManager menuManager;
		VenueFilter venueFilter;
		VenueUtilities venueUtilities;
		
		#ifndef UNIT_TESTING

		ConfigManager configManager;
		CsvReader csvReader;
		CurlHandleWrapper& curlWrapper = CurlHandleWrapper::getInstance();
		
		int main() {
			// ... (truncated for brevity)
			return 0;
		}
		#endif // UNIT_TESTING
	\end{lstlisting}
\end{mdframed}
	
	\subsection*{Explanation}
	\begin{itemize}
		\item \textbf{Dependencies}: The main source file includes its corresponding header and makes use of two namespaces: `confPaths` and `std`.
		
		\item \textbf{Global Objects}: Several global objects are declared and will be used across different parts of the code. These objects handle configuration management, CSV reading, cURL operations, email management, encryption, menu display, venue filtering, and venue utility operations.
		
		\item \textbf{Main Function} (\texttt{int main()}): The entry point to the program. The function does the following:
		\begin{itemize}
			\item Initializes various variables and loads configurations from a JSON file.
			
			\item Sets up and initializes CURL.
			
			\item Reads venue data from a CSV file and extracts unique genres, states, cities, and capacities.
			
			\item Contains the main loop to display menu options, filter venues based on user criteria, view and edit email settings, and send emails to selected venues.
			
			\item Handles exit scenarios and cleanup tasks.
		\end{itemize}
		
			\item \textbf{Conditional Compilation}: The main source file's entire body uses an \texttt{\#ifndef UNIT\_TESTING} directive. This implies that if \texttt{UNIT\_TESTING} is defined (likely during unit tests), the main function won't compile. Excluding parts of code during unit testing is a common practice.
	\end{itemize}
	
	\subsection{main.h}
	
	\subsection*{Header File}
	\begin{mdframed}[backgroundcolor=background, hidealllines=false, innerleftmargin=15pt, innerrightmargin=5pt, innertopmargin=0pt, innerbottommargin=-5pt, linecolor=accent]
	\begin{lstlisting}[language=C++]
		#ifndef MAIL_H
		#define MAIL_H
		
		#include "curl.h"
		#include "fileutils.h"
		#include "menu.h"
		#include "errorhandler.h"
		#include "structs.h"
		
		#include <ctime>
		#include <filesystem>
		#include <regex>
		#include <thread>
		
		class EmailManager {
			public:
			static inline const int MAX_MESSAGE_LENGTH = 2000;
			static inline const int MAX_SUBJECT_LENGTH = 50;
			const size_t MAX_ATTACHMENT_SIZE = 24 * 1024 * 1024;
			
			std::string getCurrentDateRfc2822();
			std::string sanitizeSubject(std::string& subject);
			void viewEmailSettings(bool useSSL, bool verifyPeer, bool verifyHost, bool verbose,  
			const std::string& senderEmail, int smtpPort, const std::string& smtpServer);
			bool isValidEmail(const std::string& email);
			void constructEmail(std::string &subject, std::string &message, std::string &attachmentPath, 
			std::string &attachmentName, std::string &attachmentSize, std::istream &in = std::cin);
			bool sendIndividualEmail(CURL* curl,
			const SelectedVenue& selectedVenue,
			const std::string& senderEmail,
			std::string& subject,
			std::string& message,
			const std::string& smtpServer,
			int smtpPort,
			std::string& attachmentName,
			std::string& attachmentSize,
			std::string& attachmentPath);
			void viewEmailSendingProgress(const std::string& senderEmail);
		};
		
		#endif // MAIL_H
	\end{lstlisting}
\end{mdframed}
	\subsection*{Explanation}
	\begin{itemize}
		\item \textbf{Header Guards}: \texttt{MAIL\_H} is used as the header guard. This ensures that the header file's content is included only once in the compilation process.
		\item \textbf{Dependencies}: This header file includes dependencies related to CURL operations, file utilities, menu options, error handling, and venue structures. Additionally, there are standard library includes for time, file system operations, regular expressions, and threading.
		\item \textbf{EmailManager Class}: 
		\begin{itemize}
			\item \textbf{Constants}: Defines maximum lengths for the email message body and subject. There's also a constant for the maximum attachment size.
			\item \textbf{Utility Functions}: Provides methods for getting the current date in RFC 2822 format, sanitizing the email subject, and displaying the email settings.
			\item \textbf{Validation}: Contains a method to validate the format of an email address.
			\item \textbf{Email Construction}: Function to construct the content of an email, including the subject, message, and attachment details.
			\item \textbf{Email Sending}: Functions to send individual emails and view the progress of the sending process.
		\end{itemize}
	\end{itemize}
	
	\newpage{}
	\section{menu.cpp}
	
	\subsection*{Source Code}
	\begin{mdframed}[backgroundcolor=background, hidealllines=false, innerleftmargin=15pt, innerrightmargin=5pt, innertopmargin=0pt, innerbottommargin=-5pt, linecolor=accent]
	\begin{lstlisting}[language=C++]
		#include "include/menu.h"
		
		using namespace std;
		
		const int MenuManager::FILTER_BY_GENRE_OPTION = static_cast<int>(MenuManager::MenuOption::FilterByGenre);
		const int MenuManager::FILTER_BY_STATE_OPTION = static_cast<int>(MenuManager::MenuOption::FilterByState);
		const int MenuManager::FILTER_BY_CITY_OPTION = static_cast<int>(MenuManager::MenuOption::FilterByCity);
		const int MenuManager::FILTER_BY_CAPACITY_OPTION = static_cast<int>(MenuManager::MenuOption::FilterByCapacity);
		
		const int MenuManager::CLEAR_SELECTED_VENUES_OPTION = static_cast<int>(MenuManager::MenuOption::ClearSelectedVenues);
		const intconst int MenuManager::CLEAR_BOOKING_TEMPLATE_OPTION = static_cast<int>(MenuManager::MenuOption::ClearBookingTemplate); MenuManager::VIEW_SELECTED_VENUES_OPTION = static_cast<int>(MenuManager::MenuOption::ViewSelectedVenues);
		const int MenuManager::SHOW_EMAIL_SETTINGS_OPTION = static_cast<int>(MenuManager::MenuOption::ShowEmailSettings);
		const int MenuManager::VIEW_EDIT_EMAILS_OPTION = static_cast<int>(MenuManager::MenuOption::ViewEditEmail);
		const int MenuManager::VENUE_BOOKING_TEMPLATE_OPTION = static_cast<int>(MenuManager::MenuOption::VenueBookingTemplate);
		const int MenuManager::EMAIL_CUSTOM_ADDRESS_OPTION = static_cast<int>(MenuManager::MenuOption::EmailCustomAddress);
		const int MenuManager::FINISH_AND_SEND_EMAILS_OPTION = static_cast<int>(MenuManager::MenuOption::FinishAndSendEmail);
		const int MenuManager::EXIT_OPTION = static_cast<int>(MenuManager::MenuOption::Exit);
		
		bool MenuManager::isValidMenuChoice(int choice) {
			return choice >= static_cast<int>(MenuOption::FilterByGenre) &&
			choice <= static_cast<int>(MenuOption::Exit);
		}
		
		int MenuManager::displayMenuOptions() {
			#ifdef UNIT_TESTING
			// ... (truncated for brevity)
			#else
			// ... (truncated for brevity)
			#endif
		}
		
		void MenuManager::displaySelectedVenues(const vector<SelectedVenue>& selectedVenues) {
			// ... (truncated for brevity)
		}
	\end{lstlisting}
	\end{mdframed}
	\subsection*{Explanation}
	\begin{itemize}
		\item \textbf{Namespace Utilization}: The standard namespace (\texttt{std}) is used throughout the code.
		\item \textbf{Menu Constants Initialization}: Constants representing different menu options are initialized using static casts.
		\item \textbf{Menu Validation}: The `isValidMenuChoice` function checks whether a given choice falls within the range of valid menu options.
		\item \textbf{Menu Display}: The `displayMenuOptions` function handles the display of the main menu. Depending on whether \texttt{UNIT\_TESTING} is defined, different behaviors are executed.
		\item \textbf{Selected Venues Display}: The `displaySelectedVenues` function shows the venues chosen by the user. If no venues are selected, an error message is displayed.
	\end{itemize}

	\subsection{menu.h}
	
	\subsection*{Header File}
	\begin{mdframed}[backgroundcolor=background, hidealllines=false, innerleftmargin=15pt, innerrightmargin=5pt, innertopmargin=0pt, innerbottommargin=-5pt, linecolor=accent]
		\begin{lstlisting}[language=C++]
			#ifndef MENU_H
			#define MENU_H
			
			#include "errorhandler.h"
			#include "fileutils.h"
			#include "structs.h"
			
			#include <iostream>
			#include <vector>
			
			// Class to manage menu-related operations
			class MenuManager {
				public:
				
				// Enumeration representing the available options in the main menu
				enum class MenuOption {
					FilterByGenre = 1,
					FilterByState,
					FilterByCity,
					FilterByCapacity,
					ClearSelectedVenues,
					ClearBookingTemplate,
					ViewSelectedVenues,
					ShowEmailSettings,
					ViewEditEmail,
					VenueBookingTemplate,
					EmailCustomAddress,
					FinishAndSendEmail,
					Exit
				};
				
				// Constants for menu options related to filtering venues
				static constexpr int FILTER_BY_GENRE_OPTION = static_cast<int>(MenuOption::FilterByGenre);
				static constexpr int FILTER_BY_STATE_OPTION = static_cast<int>(MenuOption::FilterByState);
				static constexpr int FILTER_BY_CITY_OPTION = static_cast<int>(MenuOption::FilterByCity);
				static constexpr int FILTER_BY_CAPACITY_OPTION = static_cast<int>(MenuOption::FilterByCapacity);
				
				// Constants for other menu options
				static constexpr int CLEAR_SELECTED_VENUES_OPTION = static_cast<int>(MenuOption::ClearSelectedVenues);
				static constexpr int CLEAR_BOOKING_TEMPLATE_OPTION = static_cast<int>(MenuOption::ClearBookingTemplate);
				static constexpr int VIEW_SELECTED_VENUES_OPTION = static_cast<int>(MenuOption::ViewSelectedVenues);
				static constexpr int SHOW_EMAIL_SETTINGS_OPTION = static_cast<int>(MenuOption::ShowEmailSettings);
				static constexpr int VIEW_EDIT_EMAILS_OPTION = static_cast<int>(MenuOption::ViewEditEmail);
				static constexpr int VENUE_BOOKING_TEMPLATE_OPTION = static_cast<int>(MenuOption::VenueBookingTemplate);
				static constexpr int EMAIL_CUSTOM_ADDRESS_OPTION = static_cast<int>(MenuOption::EmailCustomAddress);
				static constexpr int FINISH_AND_SEND_EMAILS_OPTION = static_cast<int>(MenuOption::FinishAndSendEmail);
				static constexpr int EXIT_OPTION = static_cast<int>(MenuOption::Exit);
				
				// Function to validate if the user's choice is a valid menu option
				inline bool isValidMenuChoice(int choice) const {
					return choice >= FILTER_BY_GENRE_OPTION && choice <= EXIT_OPTION;
				}
				
				// Function to display the available menu options to the user
				int displayMenuOptions();
				
				// Function to display the list of venues selected by the user
				void displaySelectedVenues(const std::vector<SelectedVenue>& selectedVenues);
				
				// Function to handle the exiting/cleanup of the program
				bool handleExitOption();
			};
			
			#endif // MENU_H
		\end{lstlisting}
	\end{mdframed}
	
	\subsection*{Explanation}
	\begin{itemize}
		\item \textbf{Header Guards}: \texttt{MENU\_H} is used to prevent double inclusion.
		\item \textbf{Dependencies}:
		\begin{itemize}
			\item \texttt{errorhandler.h}: For handling errors.
			\item \texttt{fileutils.h}: Utility functions for file operations.
			\item \texttt{structs.h}: Contains the structure definitions used in the program.
			\item \texttt{iostream}: For standard input/output operations.
			\item \texttt{vector}: For using the vector data structure.
		\end{itemize}
		\item \textbf{Class Definition}:
		\begin{itemize}
			\item \texttt{MenuManager}: A class dedicated to manage menu-related operations.
			\item \textbf{MenuOption Enumeration}: Represents the available options in the main menu.
			\item \textbf{Constants for Menu Options}: These constants are used to represent the different menu options available to the user.
			\item \textbf{isValidMenuChoice(int choice)}: Validates if the user's menu choice is within the range of valid options.
			\item \textbf{displayMenuOptions()}: Displays the available menu options to the user and returns the user's choice.
			\item \textbf{displaySelectedVenues(const std::vector<SelectedVenue>\& selectedVenues)}: Displays the list of venues that the user has selected.
		\end{itemize}
	\end{itemize}
	
	\section{filtercriteria.cpp}
	
	\subsection*{Source Code}
	\begin{mdframed}[backgroundcolor=background, hidealllines=false, innerleftmargin=15pt, innerrightmargin=5pt, innertopmargin=0pt, innerbottommargin=-5pt, linecolor=accent]
	\begin{lstlisting}[language=C++]
		#include "include/filtercriteria.h"
		
		// Use the standard namespace
		using namespace std;
		
		// Utility function to convert a Venue object to a SelectedVenue object
		SelectedVenue VenueUtilities::convertToSelectedVenue(const Venue& venue) {
			// ... (truncated for brevity)
		}
		
		// Utility function to get unique genres from a list of venues
		set<string> VenueUtilities::getUniqueGenres(const vector<Venue>& venues) {
			// ... (truncated for brevity)
		}
		
		// Utility function to get unique states from a list of venues
		set<string> VenueUtilities::getUniqueStates(const vector<Venue>& venues) {
			// ... (truncated for brevity)
		}
		
		// Utility function to get unique cities from a list of venues
		set<string> VenueUtilities::getUniqueCities(const vector<Venue>& venues) {
			// ... (truncated for brevity)
		}
		
		// Utility function to get unique capacities from a list of venues
		set<int> VenueUtilities::getUniqueCapacities(const vector<Venue>& venues) {
			// ... (truncated for brevity)
		}
		
		// Function to process venue selection based on user input
		void VenueFilter::processVenueSelection(const vector<SelectedVenue>& temporaryFilteredVenues,
		vector<SelectedVenue>& selectedVenuesForEmail,
		istream& input,
		ostream& output) {
			// ... (truncated for brevity)
		}
		
		// Function to display filtered venues to the user
		void VenueFilter::displayFilteredVenues(const vector<SelectedVenue>& selectedVenuesForDisplay) {
			// ... (truncated for brevity)
		}
		
		// Common function for filtering venues by Genre, State, or City
		vector<SelectedVenue> VenueFilter::filterByOptionCommon(const vector<Venue>& venues,
		const set<string>& uniqueOptions,
		const string& filterType,
		vector<SelectedVenue>& temporaryFilteredVenues) {
			// ... (truncated for brevity)
		}
		
		// Function to filter venues by Genre, State, or City
		vector<SelectedVenue> VenueFilter::filterByOption(const vector<Venue>& venues,
		const string& filterType,
		const set<string>& uniqueOptions,
		vector<SelectedVenue>& temporaryFilteredVenues) {
			// ... (truncated for brevity)
		}
		
		// Function to filter venues by Capacity
		vector<SelectedVenue> VenueFilter::filterByCapacity(const vector<Venue>& venues,
		const set<int>& uniqueCapacities,
		vector<SelectedVenue>& temporaryFilteredVenues) {
			// ... (truncated for brevity)
		}
	\end{lstlisting}
\end{mdframed}
	\subsection*{Explanation}
	\begin{itemize}
		\item \textbf{Namespace Utilization}: The standard namespace (\texttt{std}) is used throughout the code.
		\item \textbf{VenueUtilities}: This class provides utility functions to convert between different types of venue objects, retrieve unique genre, state, city, and capacity values from a list of venues.
		\item \textbf{VenueFilter}: This class contains functions to filter and display venues based on different criteria such as genre, state, city, and capacity.
		\begin{itemize}
			\item \texttt{processVenueSelection()}: Processes venue selection based on user input and updates the list of venues to be emailed.
			\item \texttt{displayFilteredVenues()}: Displays the venues that match the applied filters.
			\item \texttt{filterByOptionCommon()}: A common function used for filtering venues based on either genre, state, or city.
			\item \texttt{filterByOption()}: Filters venues by genre, state, or city.
			\item \texttt{filterByCapacity()}: Filters venues based on their capacity.
		\end{itemize}
	\end{itemize}
	
	\subsection{filtercriteria.h}
	
	\subsection*{Header File}
	\begin{mdframed}[backgroundcolor=background, hidealllines=false, innerleftmargin=15pt, innerrightmargin=5pt, innertopmargin=0pt, innerbottommargin=-5pt, linecolor=accent]
		\begin{lstlisting}[language=C++]
			#ifndef FILTERCRITERIA_H
			#define FILTERCRITERIA_H
			
			#include "fileutils.h"
			#include "structs.h"
			
			#include <iomanip>
			#include <iostream>
			#include <set>
			#include <vector>
			
			// Structure to hold filter criteria for venues
			struct FilterCriteria {
				std::string genre;
				std::string state;
				std::string city;
			};
			
			// Utility class to perform common venue-related operations
			class VenueUtilities {
				public:
				// Utility function to convert a Venue object to a SelectedVenue object
				inline static SelectedVenue convertToSelectedVenue(const Venue& venue) {
					// Create a SelectedVenue instance based on Venue data
					SelectedVenue selectedVenue;
					selectedVenue.name = venue.name;
					selectedVenue.email = venue.email;
					selectedVenue.genre = venue.genre;
					selectedVenue.state = venue.state;
					selectedVenue.city = venue.city;
					selectedVenue.capacity = venue.capacity;
					return selectedVenue;
				}
				
				// Utility function to get unique genres from a list of venues
				inline std::set<std::string> getUniqueGenres(const std::vector<Venue>& venues) {
					std::set<std::string> uniqueGenres;
					for (const auto& venue : venues) {
						if (uniqueGenres.find(venue.genre) == uniqueGenres.end()) {
							uniqueGenres.insert(venue.genre);
						}
					}
					return uniqueGenres;
				}
				
				// Utility function to get unique states from a list of venues
				inline std::set<std::string> getUniqueStates(const std::vector<Venue>& venues) {
					std::set<std::string> uniqueStates;
					for (const auto& venue : venues) {
						if (uniqueStates.find(venue.state) == uniqueStates.end()) {
							uniqueStates.insert(venue.state);
						}
					}
					return uniqueStates;
				}
				
				// Utility function to get unique cities from a list of venues
				inline std::set<std::string> getUniqueCities(const std::vector<Venue>& venues) {
					std::set<std::string> uniqueCities;
					for (const auto& venue : venues) {
						if (uniqueCities.find(venue.city) == uniqueCities.end()) {
							uniqueCities.insert(venue.city);
						}
					}
					return uniqueCities;
				}
				
				// Utility function to get unique capacities from a list of venues
				inline std::set<int> getUniqueCapacities(const std::vector<Venue>& venues) {
					std::set<int> uniqueCapacities;
					for (const Venue& venue : venues) {
						uniqueCapacities.insert(venue.capacity);
					}
					return uniqueCapacities;
				}
			};
			
			// Class to handle venue filtering logic
			class VenueFilter {
				private:
				// Max length for venue selection indices input
				const std::string::size_type MAX_INPUT_LENGTH = 256;
				
				// Delimiter used in CSV files
				const char CSV_DELIMITER = ','; // Delimiter used in CSV files
				
				// Common function to handle venue filtering by options like Genre, State, City
				std::vector<SelectedVenue> filterByOptionCommon(const std::vector<Venue>& venues,
				const std::set<std::string>& uniqueOptions,
				const std::string& filterType,
				std::vector<SelectedVenue>& temporaryFilteredVenues);
				
				std::vector<SelectedVenue> selectedVenuesForEmail;
				
				public:
				// Function to process user input and select venues based on it
				void processVenueSelection(const std::vector<SelectedVenue>& temporaryFilteredVenues,
				std::vector<SelectedVenue>& selectedVenuesForEmail,
				std::istream& input = std::cin,
				std::ostream& output = std::cout);
				
				// Function to display the filtered venues to the user
				void displayFilteredVenues(const std::vector<SelectedVenue>& selectedVenuesForDisplay);
				
				
				// Function to filter venues based on a specific option (Genre, State, etc.)
				std::vector<SelectedVenue> filterByOption(const std::vector<Venue>& venues,
				const std::string& filterType,
				const std::set<std::string>& uniqueOptions,
				std::vector<SelectedVenue>& temporaryFilteredVenues);
				
				// Function to filter venues based on capacity
				std::vector<SelectedVenue> filterByCapacity(const std::vector<Venue>& venues,
				const std::set<int>& uniqueCapacities,
				std::vector<SelectedVenue>& temporaryFilteredVenues);
			};
			
			#endif // FILTERCRITERIA_H
		\end{lstlisting}
	\end{mdframed}
	
	\subsection*{Explanation}
	\begin{itemize}
		\item \textbf{Dependencies}: The header file includes dependencies related to file utilities, struct definitions, and various standard libraries like iostream, vector, set, and iomanip.
		
		\item \textbf{Struct Definition: FilterCriteria}:
		\begin{itemize}
			\item Represents the filter criteria used to filter venues based on genre, state, and city.
		\end{itemize}
		
		\item \textbf{Class Definition: VenueUtilities}:
		\begin{itemize}
			\item A utility class that provides several static methods related to venues. It offers functions to extract unique genres, states, cities, and capacities from a list of venues. Additionally, there's a function to convert a `Venue` object to a `SelectedVenue` object.
		\end{itemize}
		
		\item \textbf{Class Definition: VenueFilter}:
		\begin{itemize}
			\item A class that manages venue filtering logic. It contains methods for processing user input related to venue selection, displaying filtered venues, filtering venues based on specific criteria like genre, state, city, and capacity. The class also maintains a list of venues selected for emailing.
		\end{itemize}
	\end{itemize}
		
	\section{structs.h}
	
	\subsection*{Header File}
	\begin{mdframed}[backgroundcolor=background, hidealllines=false, innerleftmargin=15pt, innerrightmargin=5pt, innertopmargin=0pt, innerbottommargin=-5pt, linecolor=accent]
	\begin{lstlisting}[language=C++]
		#ifndef STRUCTS_H
		#define STRUCTS_H
		
		#include <iostream>
		
		struct Venue {
			std::string name;
			std::string email;
			std::string genre;
			std::string state;
			std::string city;
			int capacity;
			
			Venue() = default;
			Venue(const std::string& name, const std::string& email, const std::string& genre,
			const std::string& state, const std::string& city, int capacity)
			: name(name), email(email), genre(genre), state(state), city(city), capacity(capacity) {}
		};
		
		struct SelectedVenue {
			std::string name;
			std::string email;
			std::string genre;
			std::string state;
			std::string city;
			int capacity;
			
			SelectedVenue() = default;
			SelectedVenue(const std::string& name, const std::string& email, const std::string& genre,
			const std::string& state, const std::string& city, int capacity)
			: name(name), email(email), genre(genre), state(state), city(city), capacity(capacity) {}
		};
		
		#endif // STRUCTS_H
	\end{lstlisting}
	\end{mdframed}
	\subsection*{Explanation}
	\begin{itemize}
		\item \textbf{Dependencies}: The header file includes the `iostream` library for string manipulation and input/output operations.
		\item \textbf{Struct Definition: Venue}:
		\begin{itemize}
			\item Represents a venue with members like name, email, genre, state, city, and capacity.
			\item \textbf{Default Constructor}: Allows creating uninitialized Venue objects.
			\item \textbf{Parameterized Constructor}: Initializes all members of the struct.
		\end{itemize}
		\item \textbf{Struct Definition: SelectedVenue}:
		\begin{itemize}
			\item Represents a selected venue with the same members as the Venue struct.
			\item \textbf{Default Constructor}: Allows creating uninitialized SelectedVenue objects.
			\item \textbf{Parameterized Constructor}: Initializes all members of the struct.
		\end{itemize}
	\end{itemize}
	
	\section{mail.cpp}
	
	\subsection*{Source Code}
	\begin{mdframed}[backgroundcolor=background, hidealllines=false, innerleftmargin=15pt, innerrightmargin=5pt, innertopmargin=0pt, innerbottommargin=-5pt, linecolor=accent]
		\begin{lstlisting}[language=C++]
			#include "include/mail.h"
			
			using namespace std;

			CurlHandleWrapper& curlHandleWrapper = CurlHandleWrapper::getInstance();
			ErrorHandler errorHandler;
			
			static int successfulSends = 0; // Counter for successful email sends
			int totalEmails;
			
			string EmailManager::getCurrentDateRfc2822() {
				// Implementation to get the current date in RFC 2822 format...
			}
			
			string EmailManager::sanitizeSubject(string& subject) {
				// Implementation to sanitize the email subject...
			}
			
			void EmailManager::viewEmailSettings(bool useSSL, bool verifyPeer, bool verifyHost, bool verbose,
			const string& senderEmail, int smtpPort, const string& smtpServer) {
				// Implementation to display current email settings...
			}
			
			bool EmailManager::isValidEmail(const string& email) {
				// Implementation to check if a provided string is a valid email format...
			}
			
			void EmailManager::constructEmail(string &subject, string &message, string &attachmentName, 
			string &attachmentSize, string &attachmentPath, istream &in) {
				// Implementation to guide the user in constructing an email...
			}

			void EmailManager::viewEditEmails(CURL* curl, const string& smtpServer, int smtpPort, vector<SelectedVenue>& selectedVenuesForEmail, const string& senderEmail, 
			string &subject, string &message, string& attachmentName, string& attachmentSize, string& attachmentPath, bool& templateExists) {
				// Implementation to view and edit emails...
				
			bool EmailManager::sendIndividualEmail(CURL* curl,
			const SelectedVenue& selectedVenue,
			const string& senderEmail,
			string& subject,
			string& message,
			const string& smtpServer,
			int smtpPort,
			string& attachmentName,
			string& attachmentSize,
			string& attachmentPath,
			vector<SelectedVenue>& selectedVenuesForEmail) {
				// Implementation to send an individual email...
			
			void EmailManager::createBookingTemplate(CURL* curl,
			const string& senderEmail,
			string& subject,
			string& message,
			const string& smtpServer,
			int smtpPort,
			string& attachmentName,
			string& attachmentSize,
			string& attachmentPath,
			vector<SelectedVenue>& selectedVenuesForEmail,
			bool& templateExists) {
				// Implementation to create an email from a booking template...
				
			void EmailManager::emailCustomAddress(CURL* curl,
			const std::string& senderEmail,
			std::string& subject,
			std::string& message,
			const std::string& smtpServer,
			int smtpPort,
			std::string& attachmentName,
			std::string& attachmentSize,
			std::string& attachmentPath) {
				// Implementation to send an individual email to a custom address...
				
			void EmailManager::confirmSendEmail(CURL* curl,
			vector<SelectedVenue>& selectedVenuesForEmail,
			const string& senderEmail,
			string& subject,
			string& message,
			const string& smtpServer,
			int smtpPort,
			string& attachmentName,
			string& attachmentSize,
			string& attachmentPath) {
				// Implementation to confirm emails before sending...
															
		\end{lstlisting}
	\end{mdframed}
	
	\subsection*{Explanation}
	\begin{itemize}
		\item \textbf{Namespace, Global Objects, and Counters}: This source file utilizes the standard namespace and a namespace alias for `filesystem`. There are global objects for cURL handling and error handling. There are also global progress counters for successful email sends and total emails.
		\item \textbf{getCurrentDateRfc2822()}: Returns the current date in RFC 2822 format.
		\item \textbf{sanitizeSubject()}: Sanitizes the subject line of an email.
		\item \textbf{viewEmailSettings()}: Displays the current email settings.
		\item \textbf{isValidEmail()}: Validates whether the provided string conforms to a valid email format.
		\item \textbf{constructEmail()}: Guides the user in constructing an email, including subject, message, and optional attachment.
		\item \textbf{viewEditEmails()}: Views the current email (if one has been created) and allows the user to edit the email.
		\item \textbf{sendIndividualEmail()}: Sends an individual email to a selected venue based on specified configurations and updates the progress of email sending.
		\item \textbf{createBookingTemplate()}: Allows the user to create an email based off of a pre-designed booking template.
		\item \textbf{emailCustomAddress()}: Sends an individual email to a custom address based on specified configurations and updates the progress of email sending.

		\item \textbf{confirmSendEmail()}: Allows the user to view the email and confirm whether to send or return to the menu.
		
	\end{itemize}
	
	\subsection{mail.h}
	
	\subsection*{Header File}
	\begin{mdframed}[backgroundcolor=background, hidealllines=false, innerleftmargin=15pt, innerrightmargin=5pt, innertopmargin=0pt, innerbottommargin=-5pt, linecolor=accent]
		\begin{lstlisting}[language=C++]
			#ifndef MAIL_H
			#define MAIL_H
			
			#include "curl.h"
			#include "encryption.h"
			#include "fileutils.h"
			#include "menu.h"
			#include "errorhandler.h"
			#include "structs.h"
			
			#include <ctime>
			#include <filesystem>
			#include <regex>
			#include <thread>
			
			// Class responsible for managing email-related operations
			class EmailManager {
				public:
				// Maximum length for email message body
				static inline const int MAX_MESSAGE_LENGTH = 2000;
				
				// Maximum length for email subject
				static inline const int MAX_SUBJECT_LENGTH = 50;
				
				// Maximum attachment size (24 MB)
				const size_t MAX_ATTACHMENT_SIZE = 24 * 1024 * 1024;  // 24 MB in bytes
				
				// Function to get the current date in RFC 2822 format
				inline std::string getCurrentDateRfc2822() {
					char buffer[100];
					time_t now;
					struct tm *tm_now;
					time(&now);
					tm_now = gmtime(&now);
					strftime(buffer, sizeof buffer, "%a, %d %b %Y %H:%M:%S %Z", tm_now);
					return buffer;
				}
				
				// Function to sanitize the subject line of an email by replacing newline and carriage return characters with spaces
				inline std::string sanitizeSubject(std::string& subject) {
					std::string sanitized = subject;
					replace(sanitized.begin(), sanitized.end(), '\n', ' '); // replace newlines with spaces
					replace(sanitized.begin(), sanitized.end(), '\r', ' '); // replace carriage returns with spaces
					return sanitized;
				}
				
				inline void clearAllEmailData(std::string &subject, std::string &message, std::string &attachmentName, std::string &attachmentSize, std::string &attachmentPath) {
					subject.clear();
					message.clear();
					attachmentName.clear();
					attachmentSize.clear();
					attachmentPath.clear();
				}
				
				inline void clearBookingTemplate(std::string &subject, std::string &message, std::string &attachmentName, std::string &attachmentSize, std::string &attachmentPath, bool& templateExists) {
					subject.clear();
					message.clear();
					attachmentName.clear();
					attachmentSize.clear();
					attachmentPath.clear();
					templateExists = false;
					ConsoleUtils::setColor(ConsoleUtils::Color::GREEN);
					std::cout << "Booking template cleared." << std::endl; 
					ConsoleUtils::resetColor();
				}
				
				inline void clearSelectedVenues(std::vector<SelectedVenue>& selectedVenuesForEmail) {
					selectedVenuesForEmail.clear();
					ConsoleUtils::setColor(ConsoleUtils::Color::GREEN);
					std::cout << "Selected venues cleared." << std::endl; 
					ConsoleUtils::resetColor();
				}
				
				inline void clearAttachmentData(std::string &attachmentName, std::string &attachmentSize, std::string &attachmentPath) {
					attachmentName.clear();
					attachmentSize.clear();
					attachmentPath.clear();
				}
				
				inline void clearSubjectMessageData(std::string &subject, std::string &message) {
					subject.clear();
					message.clear();
				}
				
				
				// Function to display the email settings from the configuration file
				void viewEmailSettings(bool useSSL, bool verifyPeer, bool verifyHost, bool verbose,  
				const std::string& senderEmail, int smtpPort, const std::string& smtpServer);
				
				// Function to validate an email address format
				bool isValidEmail(const std::string& email);
				
				// Function to construct an email, including the subject, message, and attachment details
				void constructEmail(std::string &subject, std::string &message, std::string &attachmentPath, std::string &attachmentName, std::string &attachmentSize, std::istream &in = std::cin);
				
				// Function to allow the user to modify the email
				void viewEditEmails(CURL* curl, 
				const std::string& smtpServer,
				int smtpPort,
				std::vector<SelectedVenue>& selectedVenuesForEmail,
				const std::string& senderEmail, 
				std::string &subject, 
				std::string &message, 
				std::string& attachmentName, 
				std::string& attachmentSize, 
				std::string& attachmentPath, 
				bool& templateExists);
				
				// Function to send an individual email to a selected venue
				bool sendIndividualEmail(CURL* curl,
				const SelectedVenue& selectedVenue,
				const std::string& senderEmail,
				std::string& subject,
				std::string& message,
				const std::string& smtpServer,
				int smtpPort,
				std::string& attachmentName,
				std::string& attachmentSize,
				std::string& attachmentPath,
				std::vector<SelectedVenue>& selectedVenuesForEmail);
				
				// Function to send a booking template email
				void createBookingTemplate(CURL* curl,
				const std::string& senderEmail,
				std::string& subject,
				std::string& message,
				const std::string& smtpServer,
				int smtpPort,
				std::string& attachmentName,
				std::string& attachmentSize,
				std::string& attachmentPath,
				std::vector<SelectedVenue>& selectedVenuesForEmail,
				bool& templateExistss);
				
				// Function to send to a custom email address
				void emailCustomAddress(CURL* curl,
				const std::string& senderEmail,
				std::string& subject,
				std::string& message,
				const std::string& smtpServer,
				int smtpPort,
				std::string& attachmentName,
				std::string& attachmentSize,
				std::string& attachmentPath);
				
				// Function to confirm the email before sending
				void confirmSendEmail(CURL* curl,
				std::vector<SelectedVenue>& selectedVenuesForEmail,
				const std::string& senderEmail,
				std::string& subject,
				std::string& message,
				const std::string& smtpServer,
				int smtpPort,
				std::string& attachmentName,
				std::string& attachmentSize,
				std::string& attachmentPath);
			};
			
			#endif // MAIL_H
		\end{lstlisting}
	\end{mdframed}
	
	\subsection*{Explanation}
	\begin{itemize}
		\item \textbf{Dependencies}: The header file includes dependencies related to cURL, file utilities, menu handling, error handling, console utilities, and data structures. Additionally, it utilizes the `ctime`, `filesystem`, `regex`, and `thread` libraries.
		\item \textbf{Class Definition: EmailManager}:
		\begin{itemize}
			\item \textbf{Constants}: The class defines constants for the maximum lengths of email messages and subjects, as well as the maximum size for attachments.
			\item \textbf{getCurrentDateRfc2822()}: Returns the current date in the RFC 2822 format.
			\item \textbf{sanitizeSubject()}: Sanitizes the subject line of an email.
			
			\item \textbf{clearAllEmailData()}: Clears subject, message, attachment name/path/size.
			\item \textbf{clearBookingTemplate()}: Clears subject, message, attachment name/path/size and sets the templateExists boolean to false.
			\item \textbf{clearSelectedVenues()}: Clears the selectedVenuesForEmail vector.
			\item \textbf{clearAttachmentData()}: Clears attachment name/path/size.
			\item \textbf{clearSubjectMessageData()}: Clears subject and message.			
			\item \textbf{viewEmailSettings()}: Displays the email settings.
			\item \textbf{isValidEmail()}: Checks if a given string is a valid email format.
			\item \textbf{constructEmail()}: Guides the user in constructing an email with options for subject, message, and attachment.
			\item \textbf{viewEditEmails()}: Views the current email (if one has been created) and allows the user to edit the email.			
			\item
			 \textbf{sendIndividualEmail()}: Sends an individual email to a selected venue, updating email sending progress dynamically.
			\item \textbf{emailCustomAddress()}: Sends an individual email to a custom address based on specified configurations and updates the progress of email sending.
			\item \textbf{confirmSendEmail()}: Allows the user to view the email and confirm whether to send or return to the menu.
			
		\end{itemize}
	\end{itemize}
	
	\section{fileutils.cpp}
	
	\subsection*{Source Code}
	\begin{mdframed}[backgroundcolor=background, hidealllines=false, innerleftmargin=15pt, innerrightmargin=5pt, innertopmargin=0pt, innerbottommargin=-5pt, linecolor=accent]
	\begin{lstlisting}[language=C++]
		#include "include/fileutils.h"
		#include "errorhandler.h" // Include due to circular dependency between fileutils.h and errorhandler.h
		
		using namespace std;
		
		namespace confPaths {
			string venuesCsvPath = "venues.csv";
			string configJsonPath = "config.json";
			string mockVenuesCsvPath = "src/test/mock_venues.csv";
			string mockConfigJsonPath = "src/test/mock_config.json";
		}
		
		string ConsoleUtils::trim(const string& str){
			const auto notSpace = [](int ch) {return !isspace(ch); };
			auto first = find_if(str.begin(), str.end(), notSpace);
			auto last = find_if(str.rbegin(), str.rend(), notSpace).base();
			return (first < last ? string(first, last) : string());
		}
		
		void ConsoleUtils::clearInputBuffer() {
			cin.clear();
			cin.ignore(numeric_limits<streamsize>::max(), '\n');
		}
		
		void ConsoleUtils::setColor(ConsoleUtils::Color color) {
			// Platform-specific code to set console colors.
			// Windows:
			#ifdef _WIN32
			HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
			switch(color) {
				case ConsoleUtils::Color::RED:
				SetConsoleTextAttribute(hConsole, FOREGROUND_RED);
				break;
				case ConsoleUtils::Color::GREEN:
				SetConsoleTextAttribute(hConsole, FOREGROUND_GREEN);
				break;
				case ConsoleUtils::Color::BLUE:
				SetConsoleTextAttribute(hConsole, FOREGROUND_BLUE);
				break;
				case ConsoleUtils::Color::MAGENTA:
				SetConsoleTextAttribute(hConsole, FOREGROUND_RED | FOREGROUND_BLUE);
				break;
				case ConsoleUtils::Color::YELLOW:
				SetConsoleTextAttribute(hConsole, FOREGROUND_RED | FOREGROUND_GREEN);
				break;
				case ConsoleUtils::Color::CYAN:
				SetConsoleTextAttribute(hConsole, FOREGROUND_GREEN | FOREGROUND_BLUE);
				break;
				case ConsoleUtils::Color::LIGHT_BLUE:
				SetConsoleTextAttribute(hConsole, FOREGROUND_BLUE | FOREGROUND_INTENSITY);
				break;
				default:
				SetConsoleTextAttribute(hConsole, FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE); // Default to white
				break;
			}
			#else
			// UNIX-like systems (using ANSI escape codes):
			switch(color) {
				case ConsoleUtils::Color::RED:
				std::cout << "\033[31m";
				break;
				case ConsoleUtils::Color::GREEN:
				std::cout << "\033[32m";
				break;
				case ConsoleUtils::Color::BLUE:
				std::cout << "\033[34m";
				break;
				case ConsoleUtils::Color::MAGENTA:
				std::cout << "\033[35m";
				break;
				case ConsoleUtils::Color::YELLOW:
				std::cout << "\033[33m";
				break;
				case ConsoleUtils::Color::CYAN:
				std::cout << "\033[36m";
				break;
				case ConsoleUtils::Color::LIGHT_BLUE:
				std::cout << "\033[94m";
				break;
				default:
				std::cout << "\033[0m"; // Reset to default
				break;
			}
			#endif
		}
		
		
		void ConsoleUtils::resetColor() {
			#ifdef _WIN32
			HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
			SetConsoleTextAttribute(hConsole, FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE); // Reset to white
			#else
			std::cout << "\033[0m"; // Reset to default for UNIX-like systems
			#endif
		}

		void CsvReader::readCSV(vector<Venue>& venues, string& venuesCsvPath) {
			ifstream file(venuesCsvPath);
			if (!file.is_open()) {
				ErrorHandler errorHandler;
				errorHandler.handleErrorAndReturn(ErrorHandler::ErrorType::CONFIG_OPEN_ERROR, venuesCsvPath);
				return;
			}
			
			string line;
			getline(file, line); // Skip header
			
			while (getline(file, line)) {
				istringstream ss(line);
				string data;
				vector<string> rowData;
				while (getline(ss, data, ',')) {
					rowData.push_back(ConsoleUtils::trim(data));
				}
				
				if (rowData.size() == 6) {
					Venue venue(rowData[0], rowData[1], rowData[2], rowData[3], rowData[4], stoi(rowData[5]));
					venues.push_back(venue);
				} else {
					ErrorHandler errorHandler;
					errorHandler.handleErrorAndReturn(ErrorHandler::ErrorType::INVALID_DATA_IN_CSV, venuesCsvPath);
				}
			}
			
			file.close();
		}
		
		ConfigManager::ConfigManager() {}
		
		bool ConfigManager::loadConfigSettings(bool& useSSL, bool& verifyPeer, bool& verifyHost, bool& verbose, 
		string& senderEmail, string& smtpUsername, 
		string& mailPass, int& smtpPort, string& smtpServer, 
		string& venuesCsvPath) {
			// Implementation includes conditional compilation for unit testing, 
			// handles encryption and decryption of email passwords, and 
			// validates the loaded settings.
		}
		
		void ConfigManager::resetConfigFile() {
			// Implementation reads the existing JSON configuration, 
			// modifies specific keys and values, and writes the updated 
			// JSON back to the file.
		}
	\end{lstlisting}
\end{mdframed}
	
	\subsection*{Explanation}
	\begin{itemize}
		\item \textbf{Namespace \texttt{confPaths}}: This namespace holds configuration file paths.
		\item \textbf{ConsoleUtils::trim}: Function to remove leading and trailing whitespace from a given string.
		\item \textbf{ConsoleUtils::setColor}: Function to set console colours.
		\item \textbf{ConsoleUtils::resetColor()}: Function to reset console colours back to defaults.
		\item \textbf{ConsoleUtils::clearInputBuffer}: Function to clear the input buffer.
		\item \textbf{CsvReader::readCSV}: Function to read venue data from a CSV file.
		\item \textbf{ConfigManager::ConfigManager}: Default constructor for the ConfigManager class.
		\item \textbf{ConfigManager::loadConfigSettings}: Function to load the configuration settings. This implementation includes conditional compilation for unit testing, handles encryption and decryption of email passwords, and validates the loaded settings.
		\item \textbf{ConfigManager::resetConfigFile}: Function to reset the configuration file. This implementation reads the existing JSON configuration, modifies specific keys and values, and writes the updated JSON back to the file.
	\end{itemize}
	
	\subsection{fileutils.h}
	
	\subsection*{Header File}
	\begin{mdframed}[backgroundcolor=background, hidealllines=false, innerleftmargin=15pt, innerrightmargin=5pt, innertopmargin=0pt, innerbottommargin=-5pt, linecolor=accent]
	\begin{lstlisting}[language=C++]
		#ifndef FILEUTILS_H
		#define FILEUTILS_H
		
		#include "encryption.h"
		#include "structs.h"
		
		#include <algorithm>
		#include <fstream> 
		#include <limits>
		#include <vector>
		
		// Include headers for JSON processing
		#include <jsoncpp/json/json.h>
		
		// Forward declaration to resolve circular dependency with errorhandler.h
		class ErrorHandler; // Forward declaration due to circular dependency between fileutils.h and errorhandler.h
		
		// Namespace to hold configuration file paths
		namespace confPaths {
			// Declare external string variables for file paths
			extern std::string venuesCsvPath;
			extern std::string configJsonPath;
			extern std::string mockVenuesCsvPath;
			extern std::string mockConfigJsonPath;
		}
		
		// Class for utility functions related to the console
		class ConsoleUtils {
			public:
			enum class Color {
				RED,
				GREEN,
				BLUE,
				MAGENTA,
				YELLOW,
				CYAN,
				LIGHT_BLUE,
				DEFAULT
			};
			
			// Function to clear the input buffer
			inline static void clearInputBuffer() {
				// Clear the input buffer
				std::cin.clear();
				std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); // Clear input buffer
			}
			
			// Method to set console text color
			static void setColor(Color color);
			
			// Method to reset console text color to default
			static void resetColor();
			
			// Method to trim leading and trailing spaces from a string
			static std::string trim(const std::string& str);
		};
		
		// Class for reading data from a CSV file
		class CsvReader {
			public:
			// Method to read CSV data and populate a vector of Venue objects
			static void readCSV(std::vector<Venue>& venues, std::string& venuesCsvPath);
		};
		
		// Class for managing configuration settings
		class ConfigManager {
			private:
			// Instance of EncryptionManager for password encryption/decryption
			EncryptionManager encryptionManager;
			
			public:
			// Default constructor
			ConfigManager();
			
			// Method to load settings from a configuration file
			bool loadConfigSettings(bool& useSSL, bool& verifyPeer, bool& verifyHost, bool& verbose, 
			std::string& senderEmail, std::string& smtpUsername, 
			std::string& mailPass, int& smtpPort, std::string& smtpServer, 
			std::string& venuesCsvPath);
			
			// Static method to reset the configuration file
			static void resetConfigFile();
		};
		
		#endif // FILEUTILS_H
	\end{lstlisting}
\end{mdframed}
	\subsection*{Explanation}
	\begin{itemize}
		\item \textbf{Header Guards}: `FILEUTILS\_H` is used to prevent the file from being included more than once in a single compilation.
		\item \textbf{Forward Declaration}: A forward declaration of `ErrorHandler` is made to resolve circular dependencies with `errorhandler.h`.
		\item \textbf{Namespace \texttt{confPaths}}: This namespace holds string variables for configuration file paths.
		\item \textbf{ConsoleUtils Class}: A utility class with static functions related to console operations, such as clearing the input buffer and trimming strings.
		\item \textbf{CsvReader Class}: A class responsible for reading data from a CSV file.
		\item \textbf{ConfigManager Class}: A class responsible for managing the configuration settings. It has an instance of the `EncryptionManager` for password encryption and decryption. This class provides methods to load settings from a configuration file and reset the configuration file.
	\end{itemize}
	
	\section{encryption.cpp}
	
	\subsection*{Source Code}
	\begin{mdframed}[backgroundcolor=background, hidealllines=false, innerleftmargin=15pt, innerrightmargin=5pt, innertopmargin=0pt, innerbottommargin=-5pt, linecolor=accent]
	\begin{lstlisting}[language=C++]
		#include "include/encryption.h"
		
		using namespace std;
		
		array<unsigned char, crypto_secretbox_KEYBYTES> globalEncryptionKey;
		array<unsigned char, crypto_secretbox_NONCEBYTES> globalEncryptionNonce;
		
		EncryptionManager::EncryptionManager() {
			if (sodium_init() < 0) {
				ErrorHandler errorHandler;
				errorHandler.handleErrorAndReturn(ErrorHandler::ErrorType::LIBSODIUM_INIT_ERROR);
				exit(EXIT_FAILURE);
			}
			
			randombytes_buf(globalEncryptionKey.data(), crypto_secretbox_KEYBYTES);
			randombytes_buf(globalEncryptionNonce.data(), crypto_secretbox_NONCEBYTES);
		}
		
		bool EncryptionManager::encryptPassword(const string& decryptedPassword, string& encryptedPassword) {
			unsigned char encryptedBuffer[crypto_secretbox_MACBYTES + decryptedPassword.size()];
			
			if (crypto_secretbox_easy(encryptedBuffer, reinterpret_cast<const unsigned char*>(decryptedPassword.c_str()), decryptedPassword.size(),
			globalEncryptionNonce.data(), globalEncryptionKey.data()) != 0) {
				ErrorHandler errorHandler;
				errorHandler.handleErrorAndReturn(ErrorHandler::ErrorType::EMAIL_PASSWORD_ENCRYPTION_ERROR);
				return false;
			}
			
			string nonceStr(reinterpret_cast<const char*>(globalEncryptionNonce.data()), globalEncryptionNonce.size());
			encryptedPassword = nonceStr + string(reinterpret_cast<const char*>(encryptedBuffer), sizeof(encryptedBuffer));
			
			return true;
		}
		
		string EncryptionManager::decryptPassword(const string& encryptedPassword) {
			const size_t NONCE_LENGTH = crypto_secretbox_NONCEBYTES;
			
			if (encryptedPassword.size() < crypto_secretbox_MACBYTES + NONCE_LENGTH) {
				ErrorHandler errorHandler;
				errorHandler.handleErrorAndReturn(ErrorHandler::ErrorType::EMAIL_PASSWORD_ENCRYPTION_FORMAT_ERROR);
				exit(EXIT_FAILURE);
			}
			
			string nonce = encryptedPassword.substr(0, NONCE_LENGTH);
			string ciphertext = encryptedPassword.substr(NONCE_LENGTH);
			unsigned char decryptedBuffer[ciphertext.size() - crypto_secretbox_MACBYTES];
			
			if (crypto_secretbox_open_easy(decryptedBuffer, 
			reinterpret_cast<const unsigned char*>(ciphertext.c_str()), 
			ciphertext.size(),
			reinterpret_cast<const unsigned char*>(nonce.c_str()), 
			globalEncryptionKey.data()) != 0) {
				ErrorHandler errorHandler;
				errorHandler.handleErrorAndReturn(ErrorHandler::ErrorType::EMAIL_PASSWORD_DECRYPTION_ERROR);
				exit(EXIT_FAILURE);
			}
			
			return string(reinterpret_cast<char*>(decryptedBuffer), ciphertext.size() - crypto_secretbox_MACBYTES);
		}
	\end{lstlisting}
\end{mdframed}
	\subsection*{Explanation}
	\begin{itemize}
		\item \textbf{globalEncryptionKey \& globalEncryptionNonce}: Global arrays to store the encryption key and nonce.
		\item \textbf{EncryptionManager::EncryptionManager}: Default constructor for the EncryptionManager class. It initializes the libsodium library and generates a random encryption key and nonce.
		\item \textbf{EncryptionManager::encryptPassword}: Utility function that encrypts a given password using the global encryption key and nonce.
		\item \textbf{EncryptionManager::decryptPassword}: Utility function that decrypts an encrypted password using the global encryption key and nonce.
	\end{itemize}
	
	\subsection{encryption.h}
	
	\subsection*{Header File}
	\begin{mdframed}[backgroundcolor=background, hidealllines=false, innerleftmargin=15pt, innerrightmargin=5pt, innertopmargin=0pt, innerbottommargin=-5pt, linecolor=accent]
	\begin{lstlisting}[language=C++]
		#ifndef ENCRYPTION_H
		#define ENCRYPTION_H
		
		#include "errorhandler.h"
		
		#include <array>
		#include <iostream>
		
		// Include libsodium for encryption/decryption functionalities
		#include <sodium.h>
		
		// Declare global encryption key and nonce arrays
		extern std::array<unsigned char, crypto_secretbox_KEYBYTES> globalEncryptionKey;
		extern std::array<unsigned char, crypto_secretbox_NONCEBYTES> globalEncryptionNonce;
		
		// EncryptionManager class to handle encryption-related functionalities
		class EncryptionManager {
			public:
			// Constructor will initialize encryption key and nonce
			EncryptionManager();
			
			// Utility function to encrypt a password
			// Parameters: 
			// decryptedPassword: The original password to encrypt
			// encryptedPassword: The encrypted password will be stored here
			// Return: true if encryption is successful, false otherwise
			static bool encryptPassword(const std::string& decryptedPassword, std::string& encryptedPassword);
			
			// Utility function to decrypt a password
			// Parameter: encryptedPassword: The encrypted password to decrypt
			// Return: The decrypted password as a string
			static std::string decryptPassword(const std::string& encryptedPassword);
		};
		
		#endif // ENCRYPTION_H
	\end{lstlisting}
	\end{mdframed}
	
	\subsection*{Explanation}
	\begin{itemize}
		\item \textbf{globalEncryptionKey \& globalEncryptionNonce}: Global arrays that store the encryption key and nonce, respectively.
		\item \textbf{EncryptionManager}: This class handles functionalities related to encryption.
		\item \textbf{EncryptionManager::EncryptionManager}: Constructor initializes the encryption key and nonce.
		\item \textbf{EncryptionManager::encryptPassword}: Utility function that encrypts a password. It takes in the original password to encrypt and stores the encrypted password in the given reference.
		\item \textbf{EncryptionManager::decryptPassword}: Utility function that decrypts a password. It takes in an encrypted password and returns the decrypted password as a string.
	\end{itemize}
	
	\section{curl.cpp}
	
	\subsection*{Source Code}
	\begin{mdframed}[backgroundcolor=background, hidealllines=false, innerleftmargin=15pt, innerrightmargin=5pt, innertopmargin=0pt, innerbottommargin=-5pt, linecolor=accent]
		\begin{lstlisting}[language=C++]
			#include "include/curl.h"
			
			#include "include/fileutils.h" // Forward declaration due to circular dependency between fileutils.h and errorhandler.h
			
			using namespace std;
			
			// CurlHandleWrapper Class Implementation
			// ...
			
			// Progress callback to show progress for email sending
			int CurlHandleWrapper::progressCallback(...){...}
			
			// Callback function to read data for sending
			size_t CurlHandleWrapper::readCallback(...){...}
			
			// Function to set SSL options
			void CurlHandleWrapper::setSSLOptions(...){...}
			
			// Constructor
			CurlHandleWrapper::CurlHandleWrapper() {...}
			
			// Destructor
			CurlHandleWrapper::~CurlHandleWrapper() {...}
			
			// Get the underlying cURL handle
			CURL* CurlHandleWrapper::get() const {...}
			
			// Global cURL initialization
			void CurlHandleWrapper::init() {...}
			
			// Global cURL cleanup
			void CurlHandleWrapper::cleanup() {...}
			
			// Setter for emailBeingSent
			void CurlHandleWrapper::setEmailBeingSent(const string& email) {...}
			
			// Getter for emailBeingSent
			string CurlHandleWrapper::getEmailBeingSent() const {...}
			
			// Clear the email being sent
			void CurlHandleWrapper::clearEmailBeingSent() {...}
			
			// Setup a cURL handle
			CURL* setupCurlHandle(...) {...}
		\end{lstlisting}
	\end{mdframed}
	
	\subsection*{Explanation}
	\begin{itemize}
		\item \textbf{CurlHandleWrapper Class}: This class provides a wrapper around the cURL handle to manage its behavior and settings.
		\item \textbf{progressCallback()}: A callback to show email sending progress.
		\item \textbf{readCallback()}: A callback function to read the data being sent.
		\item \textbf{setSSLOptions()}: Configures SSL options for the cURL session.
		\item \textbf{Constructor and Destructor}: Manages the lifecycle of the cURL handle.
		\item \textbf{get()}: Returns the underlying cURL handle.
		\item \textbf{init() and cleanup()}: Global initialization and cleanup functions for cURL.
		\item \textbf{setEmailBeingSent(), getEmailBeingSent(), and clearEmailBeingSent()}: Manage the email currently being sent.
		\item \textbf{setupCurlHandle()}: Configures a cURL handle with various settings.
	\end{itemize}
	
	\subsection{curl.h}
	
	\subsection*{Header File}
	\begin{mdframed}[backgroundcolor=background, hidealllines=false, innerleftmargin=15pt, innerrightmargin=5pt, innertopmargin=0pt, innerbottommargin=-5pt, linecolor=accent]
		\begin{lstlisting}[language=C++]
			#ifndef CURL_H
			#define CURL_H
			
			#include "errorhandler.h"
			
			#include <algorithm>
			#include <cstring>
			#include <iostream>
			#include <mutex>
			
			// Include headers for email processing
			#include <curl/curl.h>
			
			// Class to manage the cURL handle and associated operations
			class CurlHandleWrapper {
				public:
				// Deleted copy constructor and assignment operator
				CurlHandleWrapper(const CurlHandleWrapper&) = delete;
				CurlHandleWrapper& operator=(const CurlHandleWrapper&) = delete;
				
				// Static method to return an instance of the class
				static CurlHandleWrapper& getInstance() {
					static CurlHandleWrapper instance; // Guaranteed to be destroyed, instantiated on first use.
					return instance;
				}
				
				// Get the cURL handle for use in other operations
				CURL* get() const;
				
				// Initialize the cURL library (should be called at program start)
				static void init();
				
				// Clean up the cURL library (should be called at program end)
				static void cleanup();
				
				inline double getProgress() const {
					return progress;
				}
				
				// Callback function to update the progress of ongoing operations
				int progressCallback(void* /*clientp*/, double dltotal, double dlnow, double /*ultotal*/, double /*ulnow*/);
				
				// Set the email address that is currently being sent
				void setEmailBeingSent(const std::string& email);
				
				// Get the email address that is currently being sent
				std::string getEmailBeingSent() const;
				
				// Clear the email address that was set
				void clearEmailBeingSent();
				
				// Set SSL options for the cURL handle
				void setSSLOptions(bool useSSL = true, bool verifyPeer = true, bool verifyHost = true);
				
				// Callback function for reading the email payload
				static size_t readCallback(void* ptr, size_t size, size_t nmemb, void* userp);
				
				private:
				CurlHandleWrapper();  // Made private to enforce Singleton pattern
				~CurlHandleWrapper(); // Destructor
				
				// The actual cURL handle
				CURL* curl;
				
				// Progress of the current cURL operation
				double progress{};
				
				// Email address of the recipient for the email being sent
				std::string emailBeingSent;
			};
			
			// Function to set up a cURL handle with the given options
			CURL* setupCurlHandle(CurlHandleWrapper &curlWrapper, bool useSSL, bool verifyPeer, bool verifyHost, bool verbose,
			const std::string& senderEmail, const std::string& smtpUsername, std::string& mailPassDecrypted, int smtpPort, const std::string& smtpServer);
			
			#endif // CURL_H
			\end{lstlisting}
	\end{mdframed}
	
	\subsection*{Explanation}
	\begin{itemize}
		\item \textbf{Dependencies}: The header file includes the `errorhandler.h` for error handling, standard libraries, the cURL library, and utilities for multi-threading.
		
		\item \textbf{Class Definition: CurlHandleWrapper}:
		\begin{itemize}
			\item This class provides a Singleton pattern to ensure a single instance of the cURL handle.
			\item The copy constructor and assignment operator are deleted to prevent copying.
			\item \textbf{getInstance()}: Provides access to the single instance of this class.
			\item \textbf{get()}: Returns the cURL handle.
			\item \textbf{init() and cleanup()}: Static methods for initializing and cleaning up the cURL library.
			\item \textbf{getProgress()}: Inline method to get the progress of the ongoing cURL operation.
			\item \textbf{progressCallback()}: Callback to update the progress of ongoing operations.
			\item \textbf{setEmailBeingSent(), getEmailBeingSent(), and clearEmailBeingSent()}: Manage the email currently being sent.
			\item \textbf{setSSLOptions()}: Configures SSL options for the cURL session.
			\item \textbf{readCallback()}: Callback function to read the email payload.
			
		\item \textbf{setupCurlHandle()}: A utility function to set up and configure a cURL handle with the given options.
		\end{itemize}
		
		
	\end{itemize}
	
	
	\section{errorhandler.cpp}
	
	\subsection*{Source Code}
	\begin{mdframed}[backgroundcolor=background, hidealllines=false, innerleftmargin=15pt, innerrightmargin=5pt, innertopmargin=0pt, innerbottommargin=-5pt, linecolor=accent]
		\begin{lstlisting}[language=C++]
			#include "include/errorhandler.h"
			#include "include/fileutils.h"
			
			using namespace std;
			
			std::mutex ErrorHandler::outputMutex;
			
			bool ErrorHandler::handleCurlError(CURLcode res) {
				if (res != CURLE_OK) {
					cerr << "CURL Error: " << curl_easy_strerror(res) << endl;
					handleErrorAndReturn(ErrorType::LIBCURL_ERROR);
					return false;
				}
				return true;
			}
			
			void ErrorHandler::handleErrorAndReturn(ErrorType error) {
				handleErrorAndReturn(error, "");
			}
			
			void ErrorHandler::handleErrorAndReturn(ErrorType error, const string& extraInfo) {
				std::lock_guard<std::mutex> lock(outputMutex);
				switch (error) {
					// ... (All the error handling cases go here)
				}
			}
		\end{lstlisting}
	\end{mdframed}
	
	\subsection*{Explanation}
	\begin{itemize}
		\item \textbf{Dependencies}: This source file imports the error handling and file utilities header files for proper functioning.
		
		\item \textbf{Mutex Initialization}: A mutex is defined for thread safety. It ensures that multiple threads don't concurrently access the error handling function, which could lead to interleaved error messages.
		
		\item \textbf{handleCurlError()}: This function checks for any cURL-related errors. If one occurs, it displays a relevant error message and returns `false`. Otherwise, it returns `true`.
		
		\item \textbf{handleErrorAndReturn() (Overloaded)}: Handles various error types and displays appropriate error messages. One version accepts only the error type, while the overloaded version accepts an error type and additional information for a more detailed error message.
		
		\item \textbf{Error Handling}: A comprehensive switch-case block is used to handle different types of errors, each providing a specific error message to help in debugging and user feedback.
	\end{itemize}
		
	\subsection{errorhandler.h}
	
	\subsection*{Header File}
	\begin{mdframed}[backgroundcolor=background, hidealllines=false, innerleftmargin=15pt, innerrightmargin=5pt, innertopmargin=0pt, innerbottommargin=-5pt, linecolor=accent]
		\begin{lstlisting}[language=C++]
			#ifndef ERRORHANDLER_H
			#define ERRORHANDLER_H
			
			#include <curl/curl.h>
			
			#include <iostream>
			#include <mutex>
			
			// Forward declarations due to circular dependency between fileutils.h and errorhandler.h
			class CsvReader; 
			class ConfigManager;
			class ConsoleUtils; 
			
			// ErrorHandler class to manage different types of errors
			class ErrorHandler {
				private:
				static std::mutex outputMutex; // Mutex for thread-safe output
				public:
				// Enumeration to represent different types of errors that can be encountered
				enum class ErrorType {
					INVALID_INPUT_ERROR,
					INVALID_MENU_INPUT_ERROR,
					INPUT_LENGTH_ERROR,
					INVALID_CHOICE_ERROR,
					INVALID_INDEX_ERROR,
					INVALID_INDEX_FORMAT_ERROR,
					NO_VENUES_SELECTED_ERROR,
					VENUE_ALREADY_SELECTED_ERROR,
					EMAIL_AND_SUBJECT_BLANK_ERROR,
					EMAIL_AND_SUBJECT_WRITE_ATTEMPTS_ERROR,
					NO_VENUES_SELECTED_FOR_EMAIL_ERROR,
					EMAIL_ERROR,
					SUBJECT_LENGTH_ERROR,
					EMAIL_MESSAGE_LENGTH_ERROR,
					EMAIL_BLANK_ERROR,
					SUBJECT_MESSAGE_ERROR,
					EMAIL_WRITING_ATTEMPTS_ERROR,
					TEMPLATE_PENDING_ERROR,
					ATTACHMENT_PATH_ERROR,
					ATTACHMENT_SIZE_ERROR,
					SENDER_EMAIL_FORMAT_ERROR,
					FILESYSTEM_ERROR,
					CONFIG_OPEN_ERROR,
					CONFIG_LOAD_ERROR,
					CONFIG_OPEN_TO_WRITE_ERROR,
					INVALID_CAPACITY_IN_CSV,
					INVALID_DATA_IN_CSV,
					LIBSODIUM_INIT_ERROR,
					ENCRYPTION_ERROR,
					DECRYPTION_ERROR,
					EMAIL_PASSWORD_ENCRYPTION_ERROR,
					EMAIL_PASSWORD_DECRYPTION_ERROR,
					EMAIL_PASSWORD_ENCRYPTION_FORMAT_ERROR,
					LIBCURL_ERROR,
					SMTP_CONNECTION_ERROR,
					SMTP_AUTH_ERROR
				};
				
				// Function to handle errors and display appropriate messages based on the type of error
				void handleErrorAndReturn(ErrorType error);
				
				// Overloaded version with extra information
				void handleErrorAndReturn(ErrorType error, const std::string& extraInfo);
				
				// Handles cURL errors and returns a boolean to indicate success/failure
				bool handleCurlError(CURLcode res);
			};
			
			#endif // ERRORHANDLER_H
		\end{lstlisting}
	\end{mdframed}
	
	\subsection*{Explanation}
	\begin{itemize}
		\item \textbf{Dependencies}: The header file includes dependencies related to cURL, input/output streams, and mutex handling for thread safety.
		
		\item \textbf{Forward Declarations}: Forward declarations for `CsvReader` and `ConfigManager` are present due to circular dependencies between `fileutils.h` and `errorhandler.h`.
		
		\item \textbf{Class Definition: ErrorHandler}:
		\begin{itemize}
			\item \textbf{Mutex}: A static mutex `outputMutex` is defined to ensure thread-safe output when handling errors.
			
			\item \textbf{ErrorType Enumeration}: Represents different types of errors that the system can encounter. This provides a clear structure to identify and handle different error scenarios.
			
			\item \textbf{handleErrorAndReturn()}: Handles various types of errors and displays appropriate error messages. There are two versions of this method: one accepts only the error type, while the overloaded version also takes additional information to provide a more detailed error message.
			
			\item \textbf{handleCurlError()}: Checks for any cURL-related errors and provides a feedback mechanism.
		\end{itemize}
	\end{itemize}
	
	
	\section{test\_venuesender.cpp}
	
	\subsection*{Source File}
	\begin{mdframed}[backgroundcolor=background, hidealllines=false, innerleftmargin=15pt, innerrightmargin=5pt, innertopmargin=0pt, innerbottommargin=-5pt, linecolor=accent]
		\begin{lstlisting}[language=C++]
			// This file is used for testing DO NOT DELETE
			
			#define CATCH_CONFIG_RUNNER
			// ... (various includes)
			
			using namespace std;
			
			class CinGuard {
				// ... (definition of CinGuard class)
			};
			
			class CoutGuard {
				// ... (definition of CoutGuard class)
			};
			
			// Test groups and test cases follow...
			
			int main( int argc, char* argv[] ) {
				// ... (main function for running tests)
			}
		\end{lstlisting}
	\end{mdframed}
	
	\subsection*{Explanation}
	\begin{itemize}
		\item \textbf{Purpose}: This source file is dedicated to unit testing. It is important to note that deleting or altering this file could impact the quality assurance process for the software.
		
		\item \textbf{Dependencies}: The file includes dependencies to header files associated with various components of the system. It also uses the Catch2 testing framework, as indicated by the \texttt{CATCH\_CONFIG\_RUNNER} preprocessor directive.

		
		\item \textbf{Utility Classes}: `CinGuard` and `CoutGuard` classes are utility classes that help in redirecting the standard input and output streams. These are especially useful in testing scenarios where you want to simulate user input or capture output for verification.
		
		\item \textbf{Test Groups}: Multiple test groups are present in this source file, each focusing on a specific component or functionality of the system. These groups include `ConsoleUtils`, `CsvReader`, `ConfigManager`, `MenuManager`, `EmailManager`, `VenueFilter`, `VenueUtilities`, and `EncryptionManager`.
		
		\item \textbf{Test Cases}: Each test group contains various test cases, which are units of testing that ascertain the correctness of specific functionalities. For instance, the `ConsoleUtils` test group has a test case for verifying the `trim` function's behavior.
		
		\item \textbf{Main Function}: At the end of the source file, a main function is defined to run all the test cases using the Catch2 framework. This main function also handles cleanup tasks after all tests have been executed.
	\end{itemize}
		
	\section{venues.csv}
	
	This file represents a CSV (Comma-Separated Values) database of music venues. Each line in the CSV file corresponds to a single venue and its attributes.
	
	\subsection*{Columns}
	The file is organized into six columns:
	\begin{enumerate}
		\item \textbf{Venue Name}: The name of the venue.
		\item \textbf{Email}: The contact email address of the venue.
		\item \textbf{Genre}: The primary genre of music played at the venue.
		\item \textbf{State}: The state in which the venue is located.
		\item \textbf{City}: The city in which the venue is located.
		\item \textbf{Capacity}: The maximum number of people the venue can accommodate.
	\end{enumerate}
	
	\subsection*{Data}
	
	\begin{tabular}{|l|l|l|l|l|r|}
		\hline
		\textbf{Venue Name} & \textbf{Email} & \textbf{Genre} & \textbf{State} & \textbf{City} & \textbf{Capacity} \\
		\hline
		Venue1 & venue1@mock.com & all & AL & Daphne & 100 \\
		\hline
		Venue2 & venue2@mock.com & all & UT & Provo & 300 \\
		\hline
	\end{tabular}
	
	\subsection*{Explanation}
	\begin{itemize}
		\item The file begins with a header row that lists the names of the columns.
		\item Each subsequent row provides details about a specific venue, with values separated by commas.
		\item For example, the "Alabama Music Box" venue is located in Mobile, Alabama, can accommodate up to 700 people, and plays music of all genres.
	\end{itemize}
	
	\section{config.json}
	
	This file contains the configuration settings related to the email sending functionality and paths to other resources.
	
	\subsection*{Attributes}
	\begin{enumerate}
		\item \textbf{email\_pass\_encrypted}: A boolean that indicates whether the email password is encrypted. (Do not change this value manually.)
		\item \textbf{email\_password}: The password of the sender's email account.
		\item \textbf{sender\_email}: The email address used to send the emails.
		\item \textbf{smtp\_port}: The port number used for the SMTP server connection.
		\item \textbf{smtp\_server}: The SMTP server address.
		\item \textbf{smtp\_username}: The username used for SMTP authentication.
		\item \textbf{useSSL}: A boolean that indicates whether SSL should be used for the connection.
		\item \textbf{venues\_csv\_path}: The path to the CSV file containing venue information.
		\item \textbf{verbose}: A boolean that indicates whether to enable verbose logging.
		\item \textbf{verifyHost}: A boolean that indicates whether to verify the host during the SMTP connection.
		\item \textbf{verifyPeer}: A boolean that indicates whether to verify the peer during the SMTP connection.
	\end{enumerate}
	
	\subsection*{Data Overview}
	
	\begin{tabular}{|l|l|}
		\hline
		\textbf{Attribute} & \textbf{Example Value} \\
		\hline
		email\_pass\_encrypted & false \\
		\hline
		email\_password & "enter\_email\_password" \\
		\hline
		sender\_email & "enter\_your\_sender\_email" \\
		\hline
		smtp\_port & 587 \\
		\hline
		smtp\_server & "enter\_your\_smtp\_server" \\
		\hline
		smtp\_username & "enter\_your\_smtp\_username" \\
		\hline
		useSSL & false \\
		\hline
		venues\_csv\_path & "venues.csv" \\
		\hline
		verbose & false \\
		\hline
		verifyHost & false \\
		\hline
		verifyPeer & false \\
		\hline
	\end{tabular}
	
	\subsection*{Explanation}
	The `config.json` file is a configuration file that contains various settings related to the email sending process and paths to required resources. It's crucial to ensure the correct values are set for the email sending to work properly. Do not change the `email\_pass\_encrypted` manually as it is controlled by the application.
	
\end{document}
