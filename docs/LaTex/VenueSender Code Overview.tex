\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{fontspec}
\usepackage{xcolor}
\usepackage{geometry}
\usepackage{listings}
\usepackage{mdframed}

\setmainfont{Arial}

\definecolor{background}{RGB}{40,40,40}
\definecolor{textcolor}{RGB}{230,230,230}
\definecolor{accent}{RGB}{90,90,255}
\pagecolor{background}
\color{textcolor}

\geometry{a4paper, margin=0.8in, top=1.2in, bottom=1.2in}

\lstdefinestyle{mystyle}{
	backgroundcolor=\color{background},
	commentstyle=\color{accent},
	keywordstyle=\color{textcolor},
	numberstyle=\tiny\color{textcolor},
	stringstyle=\color{accent},
	basicstyle=\ttfamily\footnotesize\color{textcolor},
	breakatwhitespace=false,
	breaklines=true,
	captionpos=b,
	keepspaces=true,
	numbers=left,
	numbersep=5pt,
	showspaces=false,
	showstringspaces=false,
	showtabs=false,
	tabsize=2
}
\lstset{style=mystyle}

% Hyperref for links
\usepackage[colorlinks=true, allcolors=accent]{hyperref}

% Header/Footer setup for dark theme
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\lhead{\color{textcolor}VenueSender Codebase Overview}
\rhead{\color{textcolor}\thepage}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}
\renewcommand{\headrule}{\hbox to\headwidth{\color{accent}\leaders\hrule height \headrulewidth\hfill}}
\renewcommand{\footrule}{\hbox to\headwidth{\color{accent}\leaders\hrule height \footrulewidth\hfill}}

% Other packages
\usepackage{enumitem}
\usepackage{microtype}

\title{VenueSender Codebase Overview}


\author{Created by Spencer Lievens}
\date{\today}

\begin{document}
	
	\maketitle
	\tableofcontents
	\newpage
	
	\section{main.cpp}
	
	\subsection*{Source Code}
	\begin{mdframed}[backgroundcolor=background, hidealllines=false, innerleftmargin=15pt, innerrightmargin=5pt, innertopmargin=0pt, innerbottommargin=-5pt]
	\begin{lstlisting}[language=C++]
		#include "include/main.h"
		
		using namespace confPaths;
		using namespace std;
		
		ConfigManager configManager;
		CsvReader csvReader;
		CurlHandleWrapper curlWrapper;
		EmailManager emailManager;
		EncryptionManager encryptionManager;
		MenuManager menuManager;
		VenueFilter venueFilter;
		VenueUtilities venueUtilities;
		
		#ifndef UNIT_TESTING

		ConfigManager configManager;
		CsvReader csvReader;
		CurlHandleWrapper& curlWrapper = CurlHandleWrapper::getInstance();
		
		int main() {
			// ... (truncated for brevity)
			return 0;
		}
		#endif // UNIT_TESTING
	\end{lstlisting}
\end{mdframed}
	
	\subsection*{Explanation}
	\begin{itemize}
		\item \textbf{Dependencies}: The main source file includes its corresponding header and makes use of two namespaces: `confPaths` and `std`.
		
		\item \textbf{Global Objects}: Several global objects are declared and will be used across different parts of the code. These objects handle configuration management, CSV reading, cURL operations, email management, encryption, menu display, venue filtering, and venue utility operations.
		
		\item \textbf{Main Function} (\texttt{int main()}): The entry point to the program. The function does the following:
		\begin{itemize}
			\item Initializes various variables and loads configurations from a JSON file.
			
			\item Sets up and initializes CURL.
			
			\item Reads venue data from a CSV file and extracts unique genres, states, cities, and capacities.
			
			\item Contains the main loop to display menu options, filter venues based on user criteria, view and edit email settings, and send emails to selected venues.
			
			\item Handles exit scenarios and cleanup tasks.
		\end{itemize}
		
			\item \textbf{Conditional Compilation}: The main source file's entire body uses an \texttt{\#ifndef UNIT\_TESTING} directive. This implies that if \texttt{UNIT\_TESTING} is defined (likely during unit tests), the main function won't compile. Excluding parts of code during unit testing is a common practice.
	\end{itemize}
	
	\subsection{main.h}
	
	\subsection*{Header File}
	\begin{mdframed}[backgroundcolor=background, hidealllines=false, innerleftmargin=15pt, innerrightmargin=5pt, innertopmargin=0pt, innerbottommargin=-5pt]
	\begin{lstlisting}[language=C++]
		#ifndef MAIL_H
		#define MAIL_H
		
		#include "curl.h"
		#include "fileutils.h"
		#include "menu.h"
		#include "errorhandler.h"
		#include "structs.h"
		
		#include <ctime>
		#include <filesystem>
		#include <regex>
		#include <thread>
		
		class EmailManager {
			public:
			static inline const int MAX_MESSAGE_LENGTH = 2000;
			static inline const int MAX_SUBJECT_LENGTH = 50;
			const size_t MAX_ATTACHMENT_SIZE = 24 * 1024 * 1024;
			
			std::string getCurrentDateRfc2822();
			std::string sanitizeSubject(std::string& subject);
			void viewEmailSettings(bool useSSL, bool verifyPeer, bool verifyHost, bool verbose,  
			const std::string& senderEmail, int smtpPort, const std::string& smtpServer);
			bool isValidEmail(const std::string& email);
			void constructEmail(std::string &subject, std::string &message, std::string &attachmentPath, 
			std::string &attachmentName, std::string &attachmentSize, std::istream &in = std::cin);
			bool sendIndividualEmail(CURL* curl,
			const SelectedVenue& selectedVenue,
			const std::string& senderEmail,
			std::string& subject,
			std::string& message,
			const std::string& smtpServer,
			int smtpPort,
			std::string& attachmentName,
			std::string& attachmentSize,
			const std::string& attachmentPath);
			void viewEmailSendingProgress(const std::string& senderEmail);
		};
		
		#endif // MAIL_H
	\end{lstlisting}
\end{mdframed}
	\subsection*{Explanation}
	\begin{itemize}
		\item \textbf{Header Guards}: \texttt{MAIL\_H} is used as the header guard. This ensures that the header file's content is included only once in the compilation process.
		\item \textbf{Dependencies}: This header file includes dependencies related to CURL operations, file utilities, menu options, error handling, and venue structures. Additionally, there are standard library includes for time, file system operations, regular expressions, and threading.
		\item \textbf{EmailManager Class}: 
		\begin{itemize}
			\item \textbf{Constants}: Defines maximum lengths for the email message body and subject. There's also a constant for the maximum attachment size.
			\item \textbf{Utility Functions}: Provides methods for getting the current date in RFC 2822 format, sanitizing the email subject, and displaying the email settings.
			\item \textbf{Validation}: Contains a method to validate the format of an email address.
			\item \textbf{Email Construction}: Function to construct the content of an email, including the subject, message, and attachment details.
			\item \textbf{Email Sending}: Functions to send individual emails and view the progress of the sending process.
		\end{itemize}
	\end{itemize}
	
	\newpage{}
	\section{menu.cpp}
	
	\subsection*{Source Code}
	\begin{mdframed}[backgroundcolor=background, hidealllines=false, innerleftmargin=15pt, innerrightmargin=5pt, innertopmargin=0pt, innerbottommargin=-5pt]
	\begin{lstlisting}[language=C++]
		#include "include/menu.h"
		
		using namespace std;
		
		const int MenuManager::FILTER_BY_GENRE_OPTION = static_cast<int>(MenuManager::MenuOption::FilterByGenre);
		const int MenuManager::FILTER_BY_STATE_OPTION = static_cast<int>(MenuManager::MenuOption::FilterByState);
		const int MenuManager::FILTER_BY_CITY_OPTION = static_cast<int>(MenuManager::MenuOption::FilterByCity);
		const int MenuManager::FILTER_BY_CAPACITY_OPTION = static_cast<int>(MenuManager::MenuOption::FilterByCapacity);
		
		const int MenuManager::CLEAR_SELECTED_VENUES_OPTION = static_cast<int>(MenuManager::MenuOption::ClearSelectedVenues);
		const int MenuManager::VIEW_SELECTED_VENUES_OPTION = static_cast<int>(MenuManager::MenuOption::ViewSelectedVenues);
		const int MenuManager::SHOW_EMAIL_SETTINGS_OPTION = static_cast<int>(MenuManager::MenuOption::ShowEmailSettings);
		const int MenuManager::VIEW_EDIT_EMAILS_OPTION = static_cast<int>(MenuManager::MenuOption::ViewEditEmail);
		const int MenuManager::EMAIL_CUSTOM_ADDRESS_OPTION = static_cast<int>(MenuManager::MenuOption::EmailCustomAddress);
		const int MenuManager::FINISH_AND_SEND_EMAILS_OPTION = static_cast<int>(MenuManager::MenuOption::FinishAndSendEmail);
		const int MenuManager::EXIT_OPTION = static_cast<int>(MenuManager::MenuOption::Exit);
		
		bool MenuManager::isValidMenuChoice(int choice) {
			return choice >= static_cast<int>(MenuOption::FilterByGenre) &&
			choice <= static_cast<int>(MenuOption::Exit);
		}
		
		int MenuManager::displayMenuOptions() {
			#ifdef UNIT_TESTING
			// ... (truncated for brevity)
			#else
			// ... (truncated for brevity)
			#endif
		}
		
		void MenuManager::displaySelectedVenues(const vector<SelectedVenue>& selectedVenues) {
			// ... (truncated for brevity)
		}
	\end{lstlisting}
	\end{mdframed}
	\subsection*{Explanation}
	\begin{itemize}
		\item \textbf{Namespace Utilization}: The standard namespace (\texttt{std}) is used throughout the code.
		\item \textbf{Menu Constants Initialization}: Constants representing different menu options are initialized using static casts.
		\item \textbf{Menu Validation}: The `isValidMenuChoice` function checks whether a given choice falls within the range of valid menu options.
		\item \textbf{Menu Display}: The `displayMenuOptions` function handles the display of the main menu. Depending on whether \texttt{UNIT\_TESTING} is defined, different behaviors are executed.
		\item \textbf{Selected Venues Display}: The `displaySelectedVenues` function shows the venues chosen by the user. If no venues are selected, an error message is displayed.
	\end{itemize}

	\subsection{menu.h}
	
	\subsection*{Header File}
	This header file defines the \texttt{MenuManager} class responsible for managing menu-related operations within VenueSender.
	
	\subsection*{Explanation}
	\begin{itemize}
		\item \textbf{Header Guards}: \texttt{MENU\_H} is used to prevent double inclusion.
		\item \textbf{Dependencies}:
		\begin{itemize}
			\item \texttt{errorhandler.h}: For handling errors.
			\item \texttt{fileutils.h}: Utility functions for file operations.
			\item \texttt{structs.h}: Contains the structure definitions used in the program.
			\item \texttt{iostream}: For standard input/output operations.
			\item \texttt{vector}: For using the vector data structure.
		\end{itemize}
		\item \textbf{Class Definition}:
		\begin{itemize}
			\item \texttt{MenuManager}: A class dedicated to manage menu-related operations.
			\item \textbf{MenuOption Enumeration}: Represents the available options in the main menu.
			\item \textbf{Constants for Menu Options}: These constants are used to represent the different menu options available to the user.
			\item \textbf{isValidMenuChoice(int choice)}: Validates if the user's menu choice is within the range of valid options.
			\item \textbf{displayMenuOptions()}: Displays the available menu options to the user and returns the user's choice.
			\item \textbf{displaySelectedVenues(const std::vector<SelectedVenue>\& selectedVenues)}: Displays the list of venues that the user has selected.
		\end{itemize}
	\end{itemize}
	
	\section{filtercriteria.cpp}
	
	\subsection*{Source Code}
	\begin{mdframed}[backgroundcolor=background, hidealllines=false, innerleftmargin=15pt, innerrightmargin=5pt, innertopmargin=0pt, innerbottommargin=-5pt]
	\begin{lstlisting}[language=C++]
		#include "include/filtercriteria.h"
		
		// Use the standard namespace
		using namespace std;
		
		// Utility function to convert a Venue object to a SelectedVenue object
		SelectedVenue VenueUtilities::convertToSelectedVenue(const Venue& venue) {
			// ... (truncated for brevity)
		}
		
		// Utility function to get unique genres from a list of venues
		set<string> VenueUtilities::getUniqueGenres(const vector<Venue>& venues) {
			// ... (truncated for brevity)
		}
		
		// Utility function to get unique states from a list of venues
		set<string> VenueUtilities::getUniqueStates(const vector<Venue>& venues) {
			// ... (truncated for brevity)
		}
		
		// Utility function to get unique cities from a list of venues
		set<string> VenueUtilities::getUniqueCities(const vector<Venue>& venues) {
			// ... (truncated for brevity)
		}
		
		// Utility function to get unique capacities from a list of venues
		set<int> VenueUtilities::getUniqueCapacities(const vector<Venue>& venues) {
			// ... (truncated for brevity)
		}
		
		// Function to process venue selection based on user input
		void VenueFilter::processVenueSelection(const vector<SelectedVenue>& temporaryFilteredVenues,
		vector<SelectedVenue>& selectedVenuesForEmail,
		istream& input,
		ostream& output) {
			// ... (truncated for brevity)
		}
		
		// Function to display filtered venues to the user
		void VenueFilter::displayFilteredVenues(const vector<SelectedVenue>& selectedVenuesForDisplay) {
			// ... (truncated for brevity)
		}
		
		// Common function for filtering venues by Genre, State, or City
		vector<SelectedVenue> VenueFilter::filterByOptionCommon(const vector<Venue>& venues,
		const set<string>& uniqueOptions,
		const string& filterType,
		vector<SelectedVenue>& temporaryFilteredVenues) {
			// ... (truncated for brevity)
		}
		
		// Function to filter venues by Genre, State, or City
		vector<SelectedVenue> VenueFilter::filterByOption(const vector<Venue>& venues,
		const string& filterType,
		const set<string>& uniqueOptions,
		vector<SelectedVenue>& temporaryFilteredVenues) {
			// ... (truncated for brevity)
		}
		
		// Function to filter venues by Capacity
		vector<SelectedVenue> VenueFilter::filterByCapacity(const vector<Venue>& venues,
		const set<int>& uniqueCapacities,
		vector<SelectedVenue>& temporaryFilteredVenues) {
			// ... (truncated for brevity)
		}
	\end{lstlisting}
\end{mdframed}
	\subsection*{Explanation}
	\begin{itemize}
		\item \textbf{Namespace Utilization}: The standard namespace (\texttt{std}) is used throughout the code.
		\item \textbf{VenueUtilities}: This class provides utility functions to convert between different types of venue objects, retrieve unique genre, state, city, and capacity values from a list of venues.
		\item \textbf{VenueFilter}: This class contains functions to filter and display venues based on different criteria such as genre, state, city, and capacity.
		\begin{itemize}
			\item \texttt{processVenueSelection()}: Processes venue selection based on user input and updates the list of venues to be emailed.
			\item \texttt{displayFilteredVenues()}: Displays the venues that match the applied filters.
			\item \texttt{filterByOptionCommon()}: A common function used for filtering venues based on either genre, state, or city.
			\item \texttt{filterByOption()}: Filters venues by genre, state, or city.
			\item \texttt{filterByCapacity()}: Filters venues based on their capacity.
		\end{itemize}
	\end{itemize}
	
	\subsection{filtercriteria.h}
	
	\subsection*{Header File}
	\begin{mdframed}[backgroundcolor=background, hidealllines=false, innerleftmargin=15pt, innerrightmargin=5pt, innertopmargin=0pt, innerbottommargin=-5pt]
		\begin{lstlisting}[language=C++]
			#ifndef FILTERCRITERIA_H
			#define FILTERCRITERIA_H
			
			#include "fileutils.h"
			#include "structs.h"
			
			#include <iomanip>
			#include <iostream>
			#include <set>
			#include <vector>
			
			struct FilterCriteria {
				std::string genre;
				std::string state;
				std::string city;
			};
			
			class VenueUtilities {
				// ... (methods and members of VenueUtilities)
			};
			
			class VenueFilter {
				// ... (methods and members of VenueFilter)
			};
			
			#endif // FILTERCRITERIA_H
		\end{lstlisting}
	\end{mdframed}
	
	\subsection*{Explanation}
	\begin{itemize}
		\item \textbf{Dependencies}: The header file includes dependencies related to file utilities, struct definitions, and various standard libraries like iostream, vector, set, and iomanip.
		
		\item \textbf{Struct Definition: FilterCriteria}:
		\begin{itemize}
			\item Represents the filter criteria used to filter venues based on genre, state, and city.
		\end{itemize}
		
		\item \textbf{Class Definition: VenueUtilities}:
		\begin{itemize}
			\item A utility class that provides several static methods related to venues. It offers functions to extract unique genres, states, cities, and capacities from a list of venues. Additionally, there's a function to convert a `Venue` object to a `SelectedVenue` object.
		\end{itemize}
		
		\item \textbf{Class Definition: VenueFilter}:
		\begin{itemize}
			\item A class that manages venue filtering logic. It contains methods for processing user input related to venue selection, displaying filtered venues, filtering venues based on specific criteria like genre, state, city, and capacity. The class also maintains a list of venues selected for emailing.
		\end{itemize}
	\end{itemize}
		
	\section{structs.h}
	
	\subsection*{Header File}
	\begin{mdframed}[backgroundcolor=background, hidealllines=false, innerleftmargin=15pt, innerrightmargin=5pt, innertopmargin=0pt, innerbottommargin=-5pt]
	\begin{lstlisting}[language=C++]
		#ifndef STRUCTS_H
		#define STRUCTS_H
		
		#include <iostream>
		
		struct Venue {
			std::string name;
			std::string email;
			std::string genre;
			std::string state;
			std::string city;
			int capacity;
			
			Venue() = default;
			Venue(const std::string& name, const std::string& email, const std::string& genre,
			const std::string& state, const std::string& city, int capacity)
			: name(name), email(email), genre(genre), state(state), city(city), capacity(capacity) {}
		};
		
		struct SelectedVenue {
			std::string name;
			std::string email;
			std::string genre;
			std::string state;
			std::string city;
			int capacity;
			
			SelectedVenue() = default;
			SelectedVenue(const std::string& name, const std::string& email, const std::string& genre,
			const std::string& state, const std::string& city, int capacity)
			: name(name), email(email), genre(genre), state(state), city(city), capacity(capacity) {}
		};
		
		#endif // STRUCTS_H
	\end{lstlisting}
	\end{mdframed}
	\subsection*{Explanation}
	\begin{itemize}
		\item \textbf{Dependencies}: The header file includes the `iostream` library for string manipulation and input/output operations.
		\item \textbf{Struct Definition: Venue}:
		\begin{itemize}
			\item Represents a venue with members like name, email, genre, state, city, and capacity.
			\item \textbf{Default Constructor}: Allows creating uninitialized Venue objects.
			\item \textbf{Parameterized Constructor}: Initializes all members of the struct.
		\end{itemize}
		\item \textbf{Struct Definition: SelectedVenue}:
		\begin{itemize}
			\item Represents a selected venue with the same members as the Venue struct.
			\item \textbf{Default Constructor}: Allows creating uninitialized SelectedVenue objects.
			\item \textbf{Parameterized Constructor}: Initializes all members of the struct.
		\end{itemize}
	\end{itemize}
	
	\section{mail.cpp}
	
	\subsection*{Source Code}
	\begin{mdframed}[backgroundcolor=background, hidealllines=false, innerleftmargin=15pt, innerrightmargin=5pt, innertopmargin=0pt, innerbottommargin=-5pt]
		\begin{lstlisting}[language=C++]
			#include "include/mail.h"
			
			using namespace std;
			namespace fs = filesystem;
			
			CurlHandleWrapper& curlHandleWrapper = CurlHandleWrapper::getInstance();
			ErrorHandler errorHandler;
			
			static int successfulSends = 0; // Counter for successful email sends
			int totalEmails;
			
			string EmailManager::getCurrentDateRfc2822() {
				// Implementation to get the current date in RFC 2822 format...
			}
			
			string EmailManager::sanitizeSubject(string& subject) {
				// Implementation to sanitize the email subject...
			}
			
			void EmailManager::viewEmailSettings(bool useSSL, bool verifyPeer, bool verifyHost, bool verbose,
			const string& senderEmail, int smtpPort, const string& smtpServer) {
				// Implementation to display current email settings...
			}
			
			bool EmailManager::isValidEmail(const string& email) {
				// Implementation to check if a provided string is a valid email format...
			}
			
			void EmailManager::constructEmail(string &subject, string &message, string &attachmentName, 
			string &attachmentSize, string &attachmentPath, istream &in) {
				// Implementation to guide the user in constructing an email...
			}

			void EmailManager::viewEditEmails(const string& senderEmail, string &subject, string &message, string& attachmentName, string& attachmentSize, string& attachmentPath) {
			// Implementation to view and edit emails...
				
			bool EmailManager::sendIndividualEmail(CURL* curl,
			const SelectedVenue& selectedVenue,
			const string& senderEmail,
			string& subject,
			string& message,
			const string& smtpServer,
			int smtpPort,
			string& attachmentName,
			string& attachmentSize,
			const string& attachmentPath,
			const vector<SelectedVenue>& selectedVenuesForEmail) {
				// Implementation to send an individual email...
			}
		
			void EmailManager::emailCustomAddress(CURL* curl,
			const std::string& senderEmail,
			std::string& subject,
			std::string& message,
			const std::string& smtpServer,
			int smtpPort,
			std::string& attachmentName,
			std::string& attachmentSize,
			std::string& attachmentPath) {
				// Implementation to send an individual email to a custom address...
				
			void EmailManager::confirmSendEmail(CURL* curl,
			const vector<SelectedVenue>& selectedVenuesForEmail,
			const string& senderEmail,
			string& subject,
			string& message,
			const string& smtpServer,
			int smtpPort,
			string& attachmentName,
			string& attachmentSize,
			string& attachmentPath) {
				// Implementation to confirm emails before sending...
															
		\end{lstlisting}
	\end{mdframed}
	
	\subsection*{Explanation}
	\begin{itemize}
		\item \textbf{Namespace, Global Objects, and Counters}: This source file utilizes the standard namespace and a namespace alias for `filesystem`. There are global objects for cURL handling and error handling. There are also global progress counters for successful email sends and total emails.
		\item \textbf{getCurrentDateRfc2822()}: Returns the current date in RFC 2822 format.
		\item \textbf{sanitizeSubject()}: Sanitizes the subject line of an email.
		\item \textbf{viewEmailSettings()}: Displays the current email settings.
		\item \textbf{isValidEmail()}: Validates whether the provided string conforms to a valid email format.
		\item \textbf{constructEmail()}: Guides the user in constructing an email, including subject, message, and optional attachment.
		\item \textbf{viewEditEmails()}: Views the current email (if one has been created) and allows the user to edit the email.
		\item \textbf{sendIndividualEmail()}: Sends an individual email to a selected venue based on specified configurations and updates the progress of email sending.
		\item \textbf{emailCustomAddress()}: Sends an individual email to a custom address based on specified configurations and updates the progress of email sending.

		\item \textbf{confirmSendEmail()}: Allows the user to view the email and confirm whether to send or return to the menu.
		
	\end{itemize}
	
	\subsection{mail.h}
	
	\subsection*{Header File}
	\begin{mdframed}[backgroundcolor=background, hidealllines=false, innerleftmargin=15pt, innerrightmargin=5pt, innertopmargin=0pt, innerbottommargin=-5pt]
		\begin{lstlisting}[language=C++]
			#ifndef MAIL_H
			#define MAIL_H
			
			#include "curl.h"
			#include "encryption.h"
			#include "fileutils.h"
			#include "menu.h"
			#include "errorhandler.h"
			#include "structs.h"
			
			#include <ctime>
			#include <filesystem>
			#include <regex>
			#include <thread>
			
			// Class responsible for managing email-related operations
			class EmailManager {
				public:
				// Maximum length for email message body
				static inline const int MAX_MESSAGE_LENGTH = 2000;
				
				// Maximum length for email subject
				static inline const int MAX_SUBJECT_LENGTH = 50;
				
				// Maximum attachment size (24 MB)
				const size_t MAX_ATTACHMENT_SIZE = 24 * 1024 * 1024;  // 24 MB in bytes
				
				// Function to get the current date in RFC 2822 format
				inline std::string getCurrentDateRfc2822() {
					char buffer[100];
					time_t now;
					struct tm *tm_now;
					time(&now);
					tm_now = gmtime(&now);
					strftime(buffer, sizeof buffer, "%a, %d %b %Y %H:%M:%S %Z", tm_now);
					return buffer;
				}
				
				// Function to sanitize the subject line of an email by replacing newline and carriage return characters with spaces
				inline std::string sanitizeSubject(std::string& subject) {
					std::string sanitized = subject;
					replace(sanitized.begin(), sanitized.end(), '\n', ' '); // replace newlines with spaces
					replace(sanitized.begin(), sanitized.end(), '\r', ' '); // replace carriage returns with spaces
					return sanitized;
				}
				
				// Function to display the email settings from the configuration file
				void viewEmailSettings(bool useSSL, bool verifyPeer, bool verifyHost, bool verbose,  
				const std::string& senderEmail, int smtpPort, const std::string& smtpServer);
				
				// Function to validate an email address format
				bool isValidEmail(const std::string& email);
				
				// Function to construct an email, including the subject, message, and attachment details
				void constructEmail(std::string &subject, std::string &message, std::string &attachmentPath, std::string &attachmentName, std::string &attachmentSize, std::istream &in = std::cin);
				
				// Function to allow the user to modify the email
				void viewEditEmails(const std::string& senderEmail, std::string &subject, std::string &message, std::string& attachmentName, std::string& attachmentSize, std::string& attachmentPath);
				
				// Function to send an individual email to a selected venue
				bool sendIndividualEmail(CURL* curl,
				const SelectedVenue& selectedVenue,
				const std::string& senderEmail,
				std::string& subject,
				std::string& message,
				const std::string& smtpServer,
				int smtpPort,
				std::string& attachmentName,
				std::string& attachmentSize,
				const std::string& attachmentPath,
				const std::vector<SelectedVenue>& selectedVenuesForEmail);
				
				// Function to send to a custom email address
				void emailCustomAddress(CURL* curl,
				const std::string& senderEmail,
				std::string& subject,
				std::string& message,
				const std::string& smtpServer,
				int smtpPort,
				std::string& attachmentName,
				std::string& attachmentSize,
				std::string& attachmentPath);
				
				// Function to confirm the email before sending
				void confirmSendEmail(CURL* curl,
				const std::vector<SelectedVenue>& selectedVenuesForEmail,
				const std::string& senderEmail,
				std::string& subject,
				std::string& message,
				const std::string& smtpServer,
				int smtpPort,
				std::string& attachmentName,
				std::string& attachmentSize,
				std::string& attachmentPath);
			};
			
			#endif // MAIL_H
			
		\end{lstlisting}
	\end{mdframed}
	
	\subsection*{Explanation}
	\begin{itemize}
		\item \textbf{Dependencies}: The header file includes dependencies related to cURL, file utilities, menu handling, error handling, console utilities, and data structures. Additionally, it utilizes the `ctime`, `filesystem`, `regex`, and `thread` libraries.
		\item \textbf{Class Definition: EmailManager}:
		\begin{itemize}
			\item \textbf{Constants}: The class defines constants for the maximum lengths of email messages and subjects, as well as the maximum size for attachments.
			\item \textbf{getCurrentDateRfc2822()}: Returns the current date in the RFC 2822 format.
			\item \textbf{sanitizeSubject()}: Sanitizes the subject line of an email.
			\item \textbf{viewEmailSettings()}: Displays the email settings.
			\item \textbf{isValidEmail()}: Checks if a given string is a valid email format.
			\item \textbf{constructEmail()}: Guides the user in constructing an email with options for subject, message, and attachment.
			\item \textbf{viewEditEmails()}: Views the current email (if one has been created) and allows the user to edit the email.			
			\item
			 \textbf{sendIndividualEmail()}: Sends an individual email to a selected venue, updating email sending progress dynamically.
			\item \textbf{emailCustomAddress()}: Sends an individual email to a custom address based on specified configurations and updates the progress of email sending.
			\item \textbf{confirmSendEmail()}: Allows the user to view the email and confirm whether to send or return to the menu.
			
		\end{itemize}
	\end{itemize}
	
	\section{fileutils.cpp}
	
	\subsection*{Source Code}
	\begin{mdframed}[backgroundcolor=background, hidealllines=false, innerleftmargin=15pt, innerrightmargin=5pt, innertopmargin=0pt, innerbottommargin=-5pt]
	\begin{lstlisting}[language=C++]
		#include "include/fileutils.h"
		#include "errorhandler.h" // Include due to circular dependency between fileutils.h and errorhandler.h
		
		using namespace std;
		
		namespace confPaths {
			string venuesCsvPath = "venues.csv";
			string configJsonPath = "config.json";
			string mockVenuesCsvPath = "src/test/mock_venues.csv";
			string mockConfigJsonPath = "src/test/mock_config.json";
		}
		
		string ConsoleUtils::trim(const string& str){
			const auto notSpace = [](int ch) {return !isspace(ch); };
			auto first = find_if(str.begin(), str.end(), notSpace);
			auto last = find_if(str.rbegin(), str.rend(), notSpace).base();
			return (first < last ? string(first, last) : string());
		}
		
		void ConsoleUtils::clearInputBuffer() {
			cin.clear();
			cin.ignore(numeric_limits<streamsize>::max(), '\n');
		}
		
		void CsvReader::readCSV(vector<Venue>& venues, string& venuesCsvPath) {
			ifstream file(venuesCsvPath);
			if (!file.is_open()) {
				ErrorHandler errorHandler;
				errorHandler.handleErrorAndReturn(ErrorHandler::ErrorType::CONFIG_OPEN_ERROR, venuesCsvPath);
				return;
			}
			
			string line;
			getline(file, line); // Skip header
			
			while (getline(file, line)) {
				istringstream ss(line);
				string data;
				vector<string> rowData;
				while (getline(ss, data, ',')) {
					rowData.push_back(ConsoleUtils::trim(data));
				}
				
				if (rowData.size() == 6) {
					Venue venue(rowData[0], rowData[1], rowData[2], rowData[3], rowData[4], stoi(rowData[5]));
					venues.push_back(venue);
				} else {
					ErrorHandler errorHandler;
					errorHandler.handleErrorAndReturn(ErrorHandler::ErrorType::INVALID_DATA_IN_CSV, venuesCsvPath);
				}
			}
			
			file.close();
		}
		
		ConfigManager::ConfigManager() {}
		
		bool ConfigManager::loadConfigSettings(bool& useSSL, bool& verifyPeer, bool& verifyHost, bool& verbose, 
		string& senderEmail, string& smtpUsername, 
		string& mailPass, int& smtpPort, string& smtpServer, 
		string& venuesCsvPath) {
			// Implementation includes conditional compilation for unit testing, 
			// handles encryption and decryption of email passwords, and 
			// validates the loaded settings.
		}
		
		void ConfigManager::resetConfigFile() {
			// Implementation reads the existing JSON configuration, 
			// modifies specific keys and values, and writes the updated 
			// JSON back to the file.
		}
	\end{lstlisting}
\end{mdframed}
	
	\subsection*{Explanation}
	\begin{itemize}
		\item \textbf{Namespace \texttt{confPaths}}: This namespace holds configuration file paths.
		\item \textbf{ConsoleUtils::trim}: Function to remove leading and trailing whitespace from a given string.
		\item \textbf{ConsoleUtils::clearInputBuffer}: Function to clear the input buffer.
		\item \textbf{CsvReader::readCSV}: Function to read venue data from a CSV file.
		\item \textbf{ConfigManager::ConfigManager}: Default constructor for the ConfigManager class.
		\item \textbf{ConfigManager::loadConfigSettings}: Function to load the configuration settings. This implementation includes conditional compilation for unit testing, handles encryption and decryption of email passwords, and validates the loaded settings.
		\item \textbf{ConfigManager::resetConfigFile}: Function to reset the configuration file. This implementation reads the existing JSON configuration, modifies specific keys and values, and writes the updated JSON back to the file.
	\end{itemize}
	
	\subsection{fileutils.h}
	
	\subsection*{Header File}
	\begin{mdframed}[backgroundcolor=background, hidealllines=false, innerleftmargin=15pt, innerrightmargin=5pt, innertopmargin=0pt, innerbottommargin=-5pt]
	\begin{lstlisting}[language=C++]
		#ifndef FILEUTILS_H
		#define FILEUTILS_H
		
		#include "encryption.h"
		#include "structs.h"
		
		#include <algorithm>
		#include <fstream> 
		#include <limits>
		#include <vector>
		#include <jsoncpp/json/json.h>
		
		class ErrorHandler;
		
		namespace confPaths {
			extern std::string venuesCsvPath;
			extern std::string configJsonPath;
			extern std::string mockVenuesCsvPath;
			extern std::string mockConfigJsonPath;
		}
		
		class ConsoleUtils {
			public:
			static void clearInputBuffer();
			static std::string trim(const std::string& str);
		};
		
		class CsvReader {
			public:
			static void readCSV(std::vector<Venue>& venues, std::string& venuesCsvPath);
		};
		
		class ConfigManager {
			private:
			EncryptionManager encryptionManager;
			
			public:
			ConfigManager();
			bool loadConfigSettings(bool& useSSL, bool& verifyPeer, bool& verifyHost, bool& verbose, 
			std::string& senderEmail, std::string& smtpUsername, 
			std::string& mailPass, int& smtpPort, std::string& smtpServer, 
			std::string& venuesCsvPath);
			static void resetConfigFile();
		};
		
		#endif // FILEUTILS_H
	\end{lstlisting}
\end{mdframed}
	\subsection*{Explanation}
	\begin{itemize}
		\item \textbf{Header Guards}: `FILEUTILS\_H` is used to prevent the file from being included more than once in a single compilation.
		\item \textbf{Forward Declaration}: A forward declaration of `ErrorHandler` is made to resolve circular dependencies with `errorhandler.h`.
		\item \textbf{Namespace \texttt{confPaths}}: This namespace holds string variables for configuration file paths.
		\item \textbf{ConsoleUtils Class}: A utility class with static functions related to console operations, such as clearing the input buffer and trimming strings.
		\item \textbf{CsvReader Class}: A class responsible for reading data from a CSV file.
		\item \textbf{ConfigManager Class}: A class responsible for managing the configuration settings. It has an instance of the `EncryptionManager` for password encryption and decryption. This class provides methods to load settings from a configuration file and reset the configuration file.
	\end{itemize}
	
	\section{encryption.cpp}
	
	\subsection*{Source Code}
	\begin{mdframed}[backgroundcolor=background, hidealllines=false, innerleftmargin=15pt, innerrightmargin=5pt, innertopmargin=0pt, innerbottommargin=-5pt]
	\begin{lstlisting}[language=C++]
		#include "include/encryption.h"
		
		using namespace std;
		
		array<unsigned char, crypto_secretbox_KEYBYTES> globalEncryptionKey;
		array<unsigned char, crypto_secretbox_NONCEBYTES> globalEncryptionNonce;
		
		EncryptionManager::EncryptionManager() {
			if (sodium_init() < 0) {
				ErrorHandler errorHandler;
				errorHandler.handleErrorAndReturn(ErrorHandler::ErrorType::LIBSODIUM_INIT_ERROR);
				exit(EXIT_FAILURE);
			}
			
			randombytes_buf(globalEncryptionKey.data(), crypto_secretbox_KEYBYTES);
			randombytes_buf(globalEncryptionNonce.data(), crypto_secretbox_NONCEBYTES);
		}
		
		bool EncryptionManager::encryptPassword(const string& decryptedPassword, string& encryptedPassword) {
			unsigned char encryptedBuffer[crypto_secretbox_MACBYTES + decryptedPassword.size()];
			
			if (crypto_secretbox_easy(encryptedBuffer, reinterpret_cast<const unsigned char*>(decryptedPassword.c_str()), decryptedPassword.size(),
			globalEncryptionNonce.data(), globalEncryptionKey.data()) != 0) {
				ErrorHandler errorHandler;
				errorHandler.handleErrorAndReturn(ErrorHandler::ErrorType::EMAIL_PASSWORD_ENCRYPTION_ERROR);
				return false;
			}
			
			string nonceStr(reinterpret_cast<const char*>(globalEncryptionNonce.data()), globalEncryptionNonce.size());
			encryptedPassword = nonceStr + string(reinterpret_cast<const char*>(encryptedBuffer), sizeof(encryptedBuffer));
			
			return true;
		}
		
		string EncryptionManager::decryptPassword(const string& encryptedPassword) {
			const size_t NONCE_LENGTH = crypto_secretbox_NONCEBYTES;
			
			if (encryptedPassword.size() < crypto_secretbox_MACBYTES + NONCE_LENGTH) {
				ErrorHandler errorHandler;
				errorHandler.handleErrorAndReturn(ErrorHandler::ErrorType::EMAIL_PASSWORD_ENCRYPTION_FORMAT_ERROR);
				exit(EXIT_FAILURE);
			}
			
			string nonce = encryptedPassword.substr(0, NONCE_LENGTH);
			string ciphertext = encryptedPassword.substr(NONCE_LENGTH);
			unsigned char decryptedBuffer[ciphertext.size() - crypto_secretbox_MACBYTES];
			
			if (crypto_secretbox_open_easy(decryptedBuffer, 
			reinterpret_cast<const unsigned char*>(ciphertext.c_str()), 
			ciphertext.size(),
			reinterpret_cast<const unsigned char*>(nonce.c_str()), 
			globalEncryptionKey.data()) != 0) {
				ErrorHandler errorHandler;
				errorHandler.handleErrorAndReturn(ErrorHandler::ErrorType::EMAIL_PASSWORD_DECRYPTION_ERROR);
				exit(EXIT_FAILURE);
			}
			
			return string(reinterpret_cast<char*>(decryptedBuffer), ciphertext.size() - crypto_secretbox_MACBYTES);
		}
	\end{lstlisting}
\end{mdframed}
	\subsection*{Explanation}
	\begin{itemize}
		\item \textbf{globalEncryptionKey \& globalEncryptionNonce}: Global arrays to store the encryption key and nonce.
		\item \textbf{EncryptionManager::EncryptionManager}: Default constructor for the EncryptionManager class. It initializes the libsodium library and generates a random encryption key and nonce.
		\item \textbf{EncryptionManager::encryptPassword}: Utility function that encrypts a given password using the global encryption key and nonce.
		\item \textbf{EncryptionManager::decryptPassword}: Utility function that decrypts an encrypted password using the global encryption key and nonce.
	\end{itemize}
	
	\subsection{encryption.h}
	
	\subsection*{Header File}
	\begin{mdframed}[backgroundcolor=background, hidealllines=false, innerleftmargin=15pt, innerrightmargin=5pt, innertopmargin=0pt, innerbottommargin=-5pt]
	\begin{lstlisting}[language=C++]
		#ifndef ENCRYPTION_H
		#define ENCRYPTION_H
		
		#include "errorhandler.h"
		
		#include <array>
		#include <iostream>
		#include <sodium.h>
		
		extern std::array<unsigned char, crypto_secretbox_KEYBYTES> globalEncryptionKey;
		extern std::array<unsigned char, crypto_secretbox_NONCEBYTES> globalEncryptionNonce;
		
		class EncryptionManager {
			public:
			EncryptionManager();
			static bool encryptPassword(const std::string& decryptedPassword, std::string& encryptedPassword);
			static std::string decryptPassword(const std::string& encryptedPassword);
		};
		
		#endif // ENCRYPTION_H
	\end{lstlisting}
	\end{mdframed}
	
	\subsection*{Explanation}
	\begin{itemize}
		\item \textbf{globalEncryptionKey \& globalEncryptionNonce}: Global arrays that store the encryption key and nonce, respectively.
		\item \textbf{EncryptionManager}: This class handles functionalities related to encryption.
		\item \textbf{EncryptionManager::EncryptionManager}: Constructor initializes the encryption key and nonce.
		\item \textbf{EncryptionManager::encryptPassword}: Utility function that encrypts a password. It takes in the original password to encrypt and stores the encrypted password in the given reference.
		\item \textbf{EncryptionManager::decryptPassword}: Utility function that decrypts a password. It takes in an encrypted password and returns the decrypted password as a string.
	\end{itemize}
	
	\section{curl.cpp}
	
	\subsection*{Source Code}
	\begin{mdframed}[backgroundcolor=background, hidealllines=false, innerleftmargin=15pt, innerrightmargin=5pt, innertopmargin=0pt, innerbottommargin=-5pt]
		\begin{lstlisting}[language=C++]
			#include "include/curl.h"
			
			using namespace std;
			
			// CurlHandleWrapper Class Implementation
			// ...
			
			// Progress callback to show progress for email sending
			int CurlHandleWrapper::progressCallback(...){...}
			
			// Callback function to read data for sending
			size_t CurlHandleWrapper::readCallback(...){...}
			
			// Function to set SSL options
			void CurlHandleWrapper::setSSLOptions(...){...}
			
			// Constructor
			CurlHandleWrapper::CurlHandleWrapper() {...}
			
			// Destructor
			CurlHandleWrapper::~CurlHandleWrapper() {...}
			
			// Get the underlying cURL handle
			CURL* CurlHandleWrapper::get() const {...}
			
			// Global cURL initialization
			void CurlHandleWrapper::init() {...}
			
			// Global cURL cleanup
			void CurlHandleWrapper::cleanup() {...}
			
			// Setter for emailBeingSent
			void CurlHandleWrapper::setEmailBeingSent(const string& email) {...}
			
			// Getter for emailBeingSent
			string CurlHandleWrapper::getEmailBeingSent() const {...}
			
			// Clear the email being sent
			void CurlHandleWrapper::clearEmailBeingSent() {...}
			
			// Setup a cURL handle
			CURL* setupCurlHandle(...) {...}
		\end{lstlisting}
	\end{mdframed}
	
	\subsection*{Explanation}
	\begin{itemize}
		\item \textbf{CurlHandleWrapper Class}: This class provides a wrapper around the cURL handle to manage its behavior and settings.
		\item \textbf{progressCallback()}: A callback to show email sending progress.
		\item \textbf{readCallback()}: A callback function to read the data being sent.
		\item \textbf{setSSLOptions()}: Configures SSL options for the cURL session.
		\item \textbf{Constructor and Destructor}: Manages the lifecycle of the cURL handle.
		\item \textbf{get()}: Returns the underlying cURL handle.
		\item \textbf{init() and cleanup()}: Global initialization and cleanup functions for cURL.
		\item \textbf{setEmailBeingSent(), getEmailBeingSent(), and clearEmailBeingSent()}: Manage the email currently being sent.
		\item \textbf{setupCurlHandle()}: Configures a cURL handle with various settings.
	\end{itemize}
	
	\subsection{curl.h}
	
	\subsection*{Header File}
	\begin{mdframed}[backgroundcolor=background, hidealllines=false, innerleftmargin=15pt, innerrightmargin=5pt, innertopmargin=0pt, innerbottommargin=-5pt]
		\begin{lstlisting}[language=C++]
			#ifndef CURL_H
			#define CURL_H
			
			#include "errorhandler.h"
			#include <algorithm>
			#include <cstring>
			#include <iostream>
			#include <mutex>
			#include <curl/curl.h>
			
			class CurlHandleWrapper {
				public:
				CurlHandleWrapper(const CurlHandleWrapper&) = delete;
				CurlHandleWrapper& operator=(const CurlHandleWrapper&) = delete;
				
				static CurlHandleWrapper& getInstance();
				CURL* get() const;
				static void init();
				static void cleanup();
				inline double getProgress() const;
				int progressCallback(void* /*clientp*/, double dltotal, double dlnow, double /*ultotal*/, double /*ulnow*/);
				void setEmailBeingSent(const std::string& email);
				std::string getEmailBeingSent() const;
				void clearEmailBeingSent();
				void setSSLOptions(bool useSSL = true, bool verifyPeer = true, bool verifyHost = true);
				static size_t readCallback(void* ptr, size_t size, size_t nmemb, void* userp);
				
				private:
				CurlHandleWrapper();
				~CurlHandleWrapper();
				CURL* curl;
				double progress{};
				std::string emailBeingSent;
				mutable std::mutex mtx;
			};
			
			CURL* setupCurlHandle(CurlHandleWrapper &curlWrapper, bool useSSL, bool verifyPeer, bool verifyHost, bool verbose,
			const std::string& senderEmail, const std::string& smtpUsername, std::string& mailPassDecrypted, int smtpPort, const std::string& smtpServer);
			
			#endif // CURL_H
		\end{lstlisting}
	\end{mdframed}
	
	\subsection*{Explanation}
	\begin{itemize}
		\item \textbf{Dependencies}: The header file includes the `errorhandler.h` for error handling, standard libraries, the cURL library, and utilities for multi-threading.
		
		\item \textbf{Class Definition: CurlHandleWrapper}:
		\begin{itemize}
			\item This class provides a Singleton pattern to ensure a single instance of the cURL handle.
			\item The copy constructor and assignment operator are deleted to prevent copying.
			\item \textbf{getInstance()}: Provides access to the single instance of this class.
			\item \textbf{get()}: Returns the cURL handle.
			\item \textbf{init() and cleanup()}: Static methods for initializing and cleaning up the cURL library.
			\item \textbf{getProgress()}: Inline method to get the progress of the ongoing cURL operation.
			\item \textbf{progressCallback()}: Callback to update the progress of ongoing operations.
			\item \textbf{setEmailBeingSent(), getEmailBeingSent(), and clearEmailBeingSent()}: Manage the email currently being sent.
			\item \textbf{setSSLOptions()}: Configures SSL options for the cURL session.
			\item \textbf{readCallback()}: Callback function to read the email payload.
			
		\item \textbf{setupCurlHandle()}: A utility function to set up and configure a cURL handle with the given options.
		\end{itemize}
		
		
	\end{itemize}
	
	
	\section{errorhandler.cpp}
	
	\subsection*{Source Code}
	\begin{mdframed}[backgroundcolor=background, hidealllines=false, innerleftmargin=15pt, innerrightmargin=5pt, innertopmargin=0pt, innerbottommargin=-5pt]
		\begin{lstlisting}[language=C++]
			#include "include/errorhandler.h"
			#include "include/fileutils.h"
			
			using namespace std;
			
			std::mutex ErrorHandler::outputMutex;
			
			bool ErrorHandler::handleCurlError(CURLcode res) {
				if (res != CURLE_OK) {
					cerr << "CURL Error: " << curl_easy_strerror(res) << endl;
					handleErrorAndReturn(ErrorType::LIBCURL_ERROR);
					return false;
				}
				return true;
			}
			
			void ErrorHandler::handleErrorAndReturn(ErrorType error) {
				handleErrorAndReturn(error, "");
			}
			
			void ErrorHandler::handleErrorAndReturn(ErrorType error, const string& extraInfo) {
				std::lock_guard<std::mutex> lock(outputMutex);
				switch (error) {
					// ... (All the error handling cases go here)
				}
			}
		\end{lstlisting}
	\end{mdframed}
	
	\subsection*{Explanation}
	\begin{itemize}
		\item \textbf{Dependencies}: This source file imports the error handling and file utilities header files for proper functioning.
		
		\item \textbf{Mutex Initialization}: A mutex is defined for thread safety. It ensures that multiple threads don't concurrently access the error handling function, which could lead to interleaved error messages.
		
		\item \textbf{handleCurlError()}: This function checks for any cURL-related errors. If one occurs, it displays a relevant error message and returns `false`. Otherwise, it returns `true`.
		
		\item \textbf{handleErrorAndReturn() (Overloaded)}: Handles various error types and displays appropriate error messages. One version accepts only the error type, while the overloaded version accepts an error type and additional information for a more detailed error message.
		
		\item \textbf{Error Handling}: A comprehensive switch-case block is used to handle different types of errors, each providing a specific error message to help in debugging and user feedback.
	\end{itemize}
		
	\subsection{errorhandler.h}
	
	\subsection*{Header File}
	\begin{mdframed}[backgroundcolor=background, hidealllines=false, innerleftmargin=15pt, innerrightmargin=5pt, innertopmargin=0pt, innerbottommargin=-5pt]
		\begin{lstlisting}[language=C++]
			#ifndef ERRORHANDLER_H
			#define ERRORHANDLER_H
			
			#include <curl/curl.h>
			#include <iostream>
			#include <mutex>
			
			class CsvReader;
			class ConfigManager;
			
			class ErrorHandler {
				private:
				static std::mutex outputMutex;
				public:
				enum class ErrorType {
					// ... (All the error types go here)
				};
				
				void handleErrorAndReturn(ErrorType error);
				void handleErrorAndReturn(ErrorType error, const std::string& extraInfo);
				bool handleCurlError(CURLcode res);
			};
			
			#endif // ERRORHANDLER_H
		\end{lstlisting}
	\end{mdframed}
	
	\subsection*{Explanation}
	\begin{itemize}
		\item \textbf{Dependencies}: The header file includes dependencies related to cURL, input/output streams, and mutex handling for thread safety.
		
		\item \textbf{Forward Declarations}: Forward declarations for `CsvReader` and `ConfigManager` are present due to circular dependencies between `fileutils.h` and `errorhandler.h`.
		
		\item \textbf{Class Definition: ErrorHandler}:
		\begin{itemize}
			\item \textbf{Mutex}: A static mutex `outputMutex` is defined to ensure thread-safe output when handling errors.
			
			\item \textbf{ErrorType Enumeration}: Represents different types of errors that the system can encounter. This provides a clear structure to identify and handle different error scenarios.
			
			\item \textbf{handleErrorAndReturn()}: Handles various types of errors and displays appropriate error messages. There are two versions of this method: one accepts only the error type, while the overloaded version also takes additional information to provide a more detailed error message.
			
			\item \textbf{handleCurlError()}: Checks for any cURL-related errors and provides a feedback mechanism.
		\end{itemize}
	\end{itemize}
	
	
	\section{test\_venuesender.cpp}
	
	\subsection*{Source File}
	\begin{mdframed}[backgroundcolor=background, hidealllines=false, innerleftmargin=15pt, innerrightmargin=5pt, innertopmargin=0pt, innerbottommargin=-5pt]
		\begin{lstlisting}[language=C++]
			// This file is used for testing DO NOT DELETE
			
			#define CATCH_CONFIG_RUNNER
			// ... (various includes)
			
			using namespace std;
			
			class CinGuard {
				// ... (definition of CinGuard class)
			};
			
			class CoutGuard {
				// ... (definition of CoutGuard class)
			};
			
			// Test groups and test cases follow...
			
			int main( int argc, char* argv[] ) {
				// ... (main function for running tests)
			}
		\end{lstlisting}
	\end{mdframed}
	
	\subsection*{Explanation}
	\begin{itemize}
		\item \textbf{Purpose}: This source file is dedicated to unit testing. It is important to note that deleting or altering this file could impact the quality assurance process for the software.
		
		\item \textbf{Dependencies}: The file includes dependencies to header files associated with various components of the system. It also uses the Catch2 testing framework, as indicated by the \texttt{CATCH\_CONFIG\_RUNNER} preprocessor directive.

		
		\item \textbf{Utility Classes}: `CinGuard` and `CoutGuard` classes are utility classes that help in redirecting the standard input and output streams. These are especially useful in testing scenarios where you want to simulate user input or capture output for verification.
		
		\item \textbf{Test Groups}: Multiple test groups are present in this source file, each focusing on a specific component or functionality of the system. These groups include `ConsoleUtils`, `CsvReader`, `ConfigManager`, `MenuManager`, `EmailManager`, `VenueFilter`, `VenueUtilities`, and `EncryptionManager`.
		
		\item \textbf{Test Cases}: Each test group contains various test cases, which are units of testing that ascertain the correctness of specific functionalities. For instance, the `ConsoleUtils` test group has a test case for verifying the `trim` function's behavior.
		
		\item \textbf{Main Function}: At the end of the source file, a main function is defined to run all the test cases using the Catch2 framework. This main function also handles cleanup tasks after all tests have been executed.
	\end{itemize}
		
	\section{venues.csv}
	
	This file represents a CSV (Comma-Separated Values) database of music venues. Each line in the CSV file corresponds to a single venue and its attributes.
	
	\subsection*{Columns}
	The file is organized into six columns:
	\begin{enumerate}
		\item \textbf{Venue Name}: The name of the venue.
		\item \textbf{Email}: The contact email address of the venue.
		\item \textbf{Genre}: The primary genre of music played at the venue.
		\item \textbf{State}: The state in which the venue is located.
		\item \textbf{City}: The city in which the venue is located.
		\item \textbf{Capacity}: The maximum number of people the venue can accommodate.
	\end{enumerate}
	
	\subsection*{Data}
	
	\begin{tabular}{|l|l|l|l|l|r|}
		\hline
		\textbf{Venue Name} & \textbf{Email} & \textbf{Genre} & \textbf{State} & \textbf{City} & \textbf{Capacity} \\
		\hline
		Venue1 & venue1@mock.com & all & AL & Daphne & 100 \\
		\hline
		Venue2 & venue2@mock.com & all & UT & Provo & 300 \\
		\hline
	\end{tabular}
	
	\subsection*{Explanation}
	\begin{itemize}
		\item The file begins with a header row that lists the names of the columns.
		\item Each subsequent row provides details about a specific venue, with values separated by commas.
		\item For example, the "Alabama Music Box" venue is located in Mobile, Alabama, can accommodate up to 700 people, and plays music of all genres.
	\end{itemize}
	
	\section{config.json}
	
	This file contains the configuration settings related to the email sending functionality and paths to other resources.
	
	\subsection*{Attributes}
	\begin{enumerate}
		\item \textbf{email\_pass\_encrypted}: A boolean that indicates whether the email password is encrypted. (Do not change this value manually.)
		\item \textbf{email\_password}: The password of the sender's email account.
		\item \textbf{sender\_email}: The email address used to send the emails.
		\item \textbf{smtp\_port}: The port number used for the SMTP server connection.
		\item \textbf{smtp\_server}: The SMTP server address.
		\item \textbf{smtp\_username}: The username used for SMTP authentication.
		\item \textbf{useSSL}: A boolean that indicates whether SSL should be used for the connection.
		\item \textbf{venues\_csv\_path}: The path to the CSV file containing venue information.
		\item \textbf{verbose}: A boolean that indicates whether to enable verbose logging.
		\item \textbf{verifyHost}: A boolean that indicates whether to verify the host during the SMTP connection.
		\item \textbf{verifyPeer}: A boolean that indicates whether to verify the peer during the SMTP connection.
	\end{enumerate}
	
	\subsection*{Data Overview}
	
	\begin{tabular}{|l|l|}
		\hline
		\textbf{Attribute} & \textbf{Example Value} \\
		\hline
		email\_pass\_encrypted & false \\
		\hline
		email\_password & "enter\_email\_password" \\
		\hline
		sender\_email & "enter\_your\_sender\_email" \\
		\hline
		smtp\_port & 587 \\
		\hline
		smtp\_server & "enter\_your\_smtp\_server" \\
		\hline
		smtp\_username & "enter\_your\_smtp\_username" \\
		\hline
		useSSL & false \\
		\hline
		venues\_csv\_path & "venues.csv" \\
		\hline
		verbose & false \\
		\hline
		verifyHost & false \\
		\hline
		verifyPeer & false \\
		\hline
	\end{tabular}
	
	\subsection*{Explanation}
	The `config.json` file is a configuration file that contains various settings related to the email sending process and paths to required resources. It's crucial to ensure the correct values are set for the email sending to work properly. Do not change the `email\_pass\_encrypted` manually as it is controlled by the application.
	
\end{document}
